{"version":3,"sources":["controllers/MMRList.ts","theme.js","controllers/DashboardController.ts","controllers/DE1Utils.ts","views/FileSelector/FileSelector.tsx","views/LinearProgressWithLabel/LinearProgressWithLabel.js","views/Title.js","views/Updater/Updater.tsx","controllers/AppController.tsx","views/AppBar.tsx","views/Dashboard/listItems.tsx","views/Dashboard/Dashboard.tsx","views/Devices/Devices.tsx","views/WSClient.tsx","views/DE1Info/DE1Info.tsx","views/UserMenu/UserMenu.tsx","App.tsx","index.tsx","models/KeyStore.ts","components/StringifyingMap.ts","controllers/MessageMaker.ts","controllers/BLE.ts","controllers/WSClient.ts"],"names":["MMRAddr","theme","createTheme","palette","primary","main","secondary","error","red","A400","DashboardController","drawers","changecount","uichild","state","currentdrawer","console","log","this","child","signalChange","name","find","val","drawername","drawer","findDrawer","undefined","contents","draweritem","children","newitem","Error","push","setState","item","visible","forEach","element","filter","ind","arr","map","CharAddr","CharLen","struct","Struct_datatostr","Struct_MMRWrite","make_MMRWrite","data","address","hi","mid","lo","dstr","unpack","pack","byteLength","Struct_FWMapRequest","make_FWMapRequest","WindowInc","FWToErase","FWToMap","FirstError","parse_FWMapRequest","bindata","decode","WindowIncrement","LastFWMRUpdate","FWMRCallback","update","check_FWMapRequest","ble","mac","a","resp","notify","success","result","results","Data","write_FWMapRequest","requestAsyncGATTWrite","FWMapRequest","write_MMR","WriteToMMR","sleep","ms","Promise","resolve","setTimeout","pushImage","requestAsyncGATTSetNotify","fro","response","cnt","so_mrf","chunk","slice","writeresp","pollForError","nexterror","eaddr","wresp","upload_Firmware","ferr","eid","errmsg","FileSelector","props","fileSelector","handleFileSelect","event","preventDefault","click","selectionChanged","target","files","onchange","document","createElement","setAttribute","buildFileSelector","addEventListener","Button","variant","onClick","React","Component","LinearProgressWithLabel","Box","sx","display","alignItems","width","mr","LinearProgress","minWidth","Typography","color","Math","round","value","Title","component","gutterBottom","Updater","setFileList","file","KeyStore","getInstance","updateKey","AppController","sendEventToSM","type","step","progress","Fragment","showState","dashcontroller","MM","MessageMaker","CurrentConnection","DebugLogList","_updateReadyStatus","ready","A_StartBLEScan","BLE0","requestScanWithCallbacks","done","entry","A_ShowMenu","A_HideMenu","A_ShowBLEScan","setActiveDrawer","A_HideBLEScan","A_DoFirmwareUpdate","filelist","readKey","arrayBuffer","filedata","res","wait","r","j","A_ReadLog","setUpForMMRReads","requestAsyncMMRRead","DebugLen","loglenresp","loglen","_readLEUInt32","payload","resultarray","Uint8Array","pos","DebugBuffer","dataresp","set","Array","from","DebugConfig","logstr","String","fromCharCode","Date","toJSON","A_SendDisconnect","requestConnect","requestGATTConnect","request","CState","S_Init","newtransition","registerForReadyUpdates","S_ConnectWSC","WSC","getReadyState","WebSocket","OPEN","nextstate","ev","getEvent","S_StartBLEScan","setItemVisible","S_SelectDE1","S_ShowMenu","S_ReadLog","S_DoFirmwareSelect","dc","addItem","S_DoFirmwareUpdate","S_Disconnect","discb","requestGATTDisconnect","S_Error","StateMap","Map","onTransition","LastState","CurrentState","_wschange","owner","key","status","before","after","CLOSED","run","evalSM","setStateCode","buf","offset","arrbuff","buffer","dv","DataView","getUint32","instance","initialstate","EventQ","Transition","StateCode","shift","_needToEvalSM","length","statecode","get","states","BLE","OurAppBar","styled","MuiAppBar","shouldForwardProp","prop","open","zIndex","transition","transitions","create","easing","sharp","duration","leavingScreen","marginLeft","enteringScreen","OurDrawer","MuiDrawer","position","whiteSpace","boxSizing","overflowX","spacing","breakpoints","up","makeDebugLogListItem","text","ListItemButton","filename","encodeURIComponent","style","body","appendChild","removeChild","download","ListItemIcon","DownloadForOfflineSharp","ListItemText","primaryTypographyProps","fontSize","componentDidMount","requestNotifyOnChanged","_logsupdated","componentWillUnmount","cancelNotify","items","render","ListSubheader","inset","header","mdTheme","wrapInPaper","Paper","p","flexDirection","wrapInGridCell","Grid","xs","Dashboard","toggleDrawer","makeListItem","details","ListItem","button","onDrawerClick","controller","setUIElement","current","getCurrentDrawer","activedrawer","dcontent","ThemeProvider","CssBaseline","Toolbar","pr","IconButton","edge","marginRight","noWrap","flexGrow","justifyContent","px","Divider","List","mainListItems","backgroundColor","mode","grey","height","overflow","Container","maxWidth","mt","mb","container","drawerContent","Copyright","pt","row_compare","b","addr","Devices","onStateChange","allowConnect","connecting","onDeviceChange","E_Status","Changed","Added","darr","keys","device","dev","createData","MAC","Name","State","sort","rows","rowsFromStore","devices","cstate","constate","row","buttonstyle","margin","TableCell","className","connect","ConnectWithoutContactSharp","CircularProgress","disconnect","BluetoothConnectedSharp","DoNotDisturbOnSharp","scan","Stack","direction","size","startIcon","RadarSharp","reqScan","disabled","Table","TableHead","TableRow","TableBody","connectIcon","WSClient","onControllerChange","updateStateFromStore","url","readyState","DE1Info","LogLines","updateLog","split","_updateProgress","percentage","_updateLog","updatecount","SeenDevices","fontFamily","UserMenu","makeOnclick","draweritems","HardwareSharp","App","addDrawer","toDrawerContentType","inputarr","ReactDOM","querySelector","globalkeystore","notifybykey","ownername","store","newvalue","keystore","fnset","oldvalue","Deleted","delete","forcenotify","_getStore","_doNotifyChanged","has","_doNotifyDeleted","delKey","changedfn","notifyset","Set","add","fn","StringifyingMap","keyMap","keyString","stringifyKey","defaultValue","values","flag","clear","command","rid","params","id","timeout","Timeout","makeReq","char","rlen","requireresponse","encode","enable","jsondata","msg","JSON","parse","DeviceMap","toString","ConnMap","IDMap","NotifyMap","Char","MMRNotifyMap","Addr","ConnectedDevices","NotifyCallbackMap","SentMap","LastID","ReadyCallbackMap","URL","WSCName","MMRMap","PendingMMRReads","MAX_ID","isBLEReady","_onmessage","makeIncomingMsgFromJSON","_procPendingMMRReads","_handleUnsolicitedUpdate","bundle","cb","req","_forget","err","_onstatechange","reset","callback","incId","requestScan","reject","scanreq","makeScan","upd","updateFromMsg","scanResultFromUpdate","devstate","UUIDs","_sendAsJSON","_sendRequest","makeConnect","connstate","connStateFromUpdate","_updateConnState","makeDisconnect","requestGATTWrite","makeGATTWrite","_makeResponseTrampoline","requestGATTRead","readlen","makeGATTRead","requestAsyncGATTRead","requestGATTSetNotify","respcallback","upcallback","trampoline","makeGATTSetNotify","MMRReadChar","_wrapWithMAC","_localMMRUpdateCB","gattn","_unpackMMRData","wordlen","_procPendingMMRRead","oldestitem","at","mmraddress","_packMMRRead","didread","requestMMRRead","readreq","len","WSClientController","addStateNotify","setMessageEventHandler","thing","send","stringify","reqtosend","asResponseOption","Buffer","ReconnectHandle","RetryInterval","MaxRetry","Notifies","Model","OnMessageCallback","WS","_on_open","_clearReconnectTimeout","notifyStateListeners","_on_close","e","reason","interval","min","checkConnection","_on_error","errorevent","close","_on_message","window","clearTimeout","CLOSING","onopen","onclose","onerror","onmessage","notifyfn"],"mappings":"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","file":"static/js/main.688ee387.chunk.js","sourcesContent":["type MMRInfoEntry = [number, string, number, string];\n\nexport type ValidMMRName = \n  \"ExternalFlash\" |\n  \"HWConfig\" |\n  \"Model\" |\n  \"CPUBoardModel\" |\n  \"v13Model\" |\n  \"CPUFirmwareBuild\" |\n  \"DebugLen\" |\n  \"DebugBuffer\" |\n  \"DebugConfig\" |\n  \"FanThreshold\" |\n  \"TankTemp\" |\n  \"HeaterUp1Flow\" |\n  \"HeaterUp2Flow\" |\n  \"WaterHeaterIdleTemp\" |\n  \"GHCInfo\" |\n  \"PrefGHCMCI\" |\n  \"MaxShotPres\" |\n  \"TargetSteamFlow\" |\n  \"SteamStartSecs\" |\n  \"SerialN\" |\n  \"HeaterV\" |\n  \"HeaterUp2Timeout\" |\n  \"CalFlowEst\" |\n  \"FlushFlowRate\" |\n  \"FlushTemp\" |\n  \"FlushTimeout\" |\n  \"HotWaterFlowRate\" |\n  \"SteamPurgeMode\" |\n  \"AllowUSBCharging\" |\n  \"AppFeatureFlags\" |\n  \"RefillKitPresent\";\n\n  export interface MMRInfo {\n    readonly Address : number,\n    readonly Name    : ValidMMRName,\n    readonly Length  : number,\n    readonly Info    : string\n  }\n  \n\nconst MMRList = [\n    [0x00000000,  \"ExternalFlash\"       , 0xFFFFF, \"Flash RW\"],\n    [0x00800000,  \"HWConfig\"            ,       4, \"HWConfig\"],\n    [0x00800004,  \"Model\"               ,       4, \"Model\"],\n    [0x00800008,  \"CPUBoardModel\"       ,       4, \"CPU Board Model * 1000. eg: 1100 = 1.1\"],\n    [0x0080000C,  \"v13Model\"            ,       4, \"v1.3+ Firmware Model (Unset = 0, DE1 = 1, DE1Plus = 2, DE1Pro = 3, DE1XL = 4, DE1Cafe = 5)\"],\n    [0x00800010,  \"CPUFirmwareBuild\"    ,       4, \"CPU Board Firmware build number. (Starts at 1000 for 1.3, increments by 1 for every build)\"],\n    [0x00802800,  \"DebugLen\"            ,       4, \"How many characters in debug buffer are valid. Accessing this pauses BLE debug logging.\"],\n    [0x00802804,  \"DebugBuffer\"         ,  0x1000, \"Last 4K of output. Zero terminated if buffer not full yet. Pauses BLE debug logging.\"],\n    [0x00803804,  \"DebugConfig\"         ,       4, \"BLEDebugConfig. (Reading restarts logging into the BLE log)\"],\n    [0x00803808,  \"FanThreshold\"        ,       4, \"Fan threshold temp\"],\n    [0x0080380C,  \"TankTemp\"            ,       4, \"Tank water temp threshold.\"],\n    [0x00803810,  \"HeaterUp1Flow\"       ,       4, \"HeaterUp Phase 1 Flow Rate\"],\n    [0x00803814,  \"HeaterUp2Flow\"       ,       4, \"HeaterUp Phase 2 Flow Rate\"],\n    [0x00803818,  \"WaterHeaterIdleTemp\" ,       4, \"Water Heater Idle Temperature\"],\n    [0x0080381C,  \"GHCInfo\"             ,       4, \"GHC Info Bitmask, 0x1 = GHC LED Controller Present, 0x2 = GHC Touch Controller_Present, 0x4 GHC Active, 0x80000000 = Factory Mode\"],\n    [0x00803820,  \"PrefGHCMCI\"          ,       4, \"TODO\"],\n    [0x00803824,  \"MaxShotPres\"         ,       4, \"TODO\"],\n    [0x00803828,  \"TargetSteamFlow\"     ,       4, \"Target steam flow rate\"],\n    [0x0080382C,  \"SteamStartSecs\"      ,       4, \"Seconds of high steam flow * 100. Valid range 0.0 - 4.0. 0 may result in an overheated heater. Be careful.\"],\n    [0x00803830,  \"SerialN\"             ,       4, \"Current serial number\"],\n    [0x00803834,  \"HeaterV\"             ,       4, \"Nominal Heater Voltage (0, 120V or 230V). +1000 if it's a set value.\"],\n    [0x00803838,  \"HeaterUp2Timeout\"    ,       4, \"HeaterUp Phase 2 Timeout\"],\n    [0x0080383C,  \"CalFlowEst\"          ,       4, \"Flow Estimation Calibration\"],\n    [0x00803840,  \"FlushFlowRate\"       ,       4, \"Flush Flow Rate\"],\n    [0x00803844,  \"FlushTemp\"           ,       4, \"Flush Temp\"],\n    [0x00803848,  \"FlushTimeout\"        ,       4, \"Flush Timeout\"],\n    [0x0080384C,  \"HotWaterFlowRate\"    ,       4, \"Hot Water Flow Rate\"],\n    [0x00803850,  \"SteamPurgeMode\"      ,       4, \"Steam Purge Mode\"],\n    [0x00803854,  \"AllowUSBCharging\"    ,       4, \"Allow USB charging\"],\n    [0x00803858,  \"AppFeatureFlags\"     ,       4, \"App Feature Flags\"],\n    [0x0080385C,  \"RefillKitPresent\"    ,       4, \"Refill Kit Present\"],\n] as const;\n\ntype NameAddr = [ValidMMRName, number];\n\nconst NameAddrList = MMRList.map( (val, ind, arr) : Readonly<NameAddr> => {\n  return [val[1], val[0]] as Readonly<NameAddr>;\n})\n\nexport enum MMRAddr {\n  ExternalFlash       = 0x00000000,\n  HWConfig            = 0x00800000,\n  Model               = 0x00800004,\n  CPUBoardModel       = 0x00800008,\n  v13Model            = 0x0080000C,\n  CPUFirmwareBuild    = 0x00800010,\n  DebugLen            = 0x00802800,\n  DebugBuffer         = 0x00802804,\n  DebugConfig         = 0x00803804,\n  FanThreshold        = 0x00803808,\n  TankTemp            = 0x0080380C,\n  HeaterUp1Flow       = 0x00803810,\n  HeaterUp2Flow       = 0x00803814,\n  WaterHeaterIdleTemp = 0x00803818,\n  GHCInfo             = 0x0080381C,\n  PrefGHCMCI          = 0x00803820,\n  MaxShotPres         = 0x00803824,\n  TargetSteamFlow     = 0x00803828,\n  SteamStartSecs      = 0x0080382C,\n  SerialN             = 0x00803830,\n  HeaterV             = 0x00803834,\n  HeaterUp2Timeout    = 0x00803838,\n  CalFlowEst          = 0x0080383C,\n  FlushFlowRate       = 0x00803840,\n  FlushTemp           = 0x00803844,\n  FlushTimeout        = 0x00803848,\n  HotWaterFlowRate    = 0x0080384C,\n  SteamPurgeMode      = 0x00803850,\n  AllowUSBCharging    = 0x00803854,\n  AppFeatureFlags     = 0x00803858,\n  RefillKitPresent    = 0x0080385C,\n}\n","import { red } from '@mui/material/colors';\nimport { createTheme } from '@mui/material/styles';\n\n// A custom theme for this app\nconst theme = createTheme({\n  palette: {\n    primary: {\n      main: '#556cd6',\n    },\n    secondary: {\n      main: '#19857b',\n    },\n    error: {\n      main: red.A400,\n    },\n  },\n});\n\nexport default theme;\n","import { Dashboard } from \"../views/Dashboard\"\n\nexport interface DrawerContentType {\n  name : string,\n  item : JSX.Element\n  visible : boolean;\n}\n\nexport interface DrawerType {\n  name : string,\n  draweritem : JSX.Element,\n  contents : DrawerContentType[]\n}\n\nexport class DashboardController {\n\n  // A drawercontent is [{ name, item }]\n  // A drawer is { name: string, draweritem : string, contents: array of drawercontents}\n\n  drawers : DrawerType[] = [];\n  changecount : number = 0;\n  uichild : Dashboard|undefined;\n  state = {\n    changecount: 0,\n    currentdrawer: \"Status\" // The current drawer that is selected\n  }\n\n  constructor() {\n    console.log(\"DashboardController constructor()\")\n  }\n\n  getCurrentDrawer() : string {\n    return this.state.currentdrawer;\n  }\n\n  setUIElement(child: Dashboard) {\n    console.log(\"setUIElement: \", this)\n    this.uichild = child;\n    this.signalChange()\n  }\n\n  findDrawer(name: string): DrawerType | undefined {\n    var d = this.drawers.find((val: DrawerType): boolean => { return val.name == name })\n    return d;\n  }\n\n  findInDrawer(drawername: string, name: string): DrawerContentType|undefined {\n    var drawer: DrawerType|undefined = this.findDrawer(drawername);\n\n    if (drawer === undefined) return undefined;\n\n    return drawer.contents.find((val: DrawerContentType) => { return val.name === name })\n  }\n\n  addDrawer(name : string, draweritem : JSX.Element, children?:DrawerContentType[]) {\n    var drawer: DrawerType | undefined = this.findDrawer(name)\n    if (drawer !== undefined) throw Error(\"Drawer \" + name + \" already exists\");\n    var newitem : DrawerType;\n    if (children !== undefined) {\n      newitem = {name, draweritem, contents : children};\n    } else {\n      newitem = {name, draweritem, contents : []};\n    }\n    this.drawers.push(newitem);  \n    this.signalChange();\n    console.log(\"After addDrawer:\", this)\n  }\n\n  private signalChange() {\n    this.changecount = this.changecount+1;\n    if (this.uichild) {\n      this.uichild.setState({changecount : this.changecount});\n    }\n  }\n\n  /**\n   * Add an item to an existing drawer\n   * @param {string} name \n   * @param {string} drawer \n   * @param {React.Component} item \n   */\n  addItem(name: string, drawername: string, item: JSX.Element, visible : boolean) {\n    var drawer: DrawerType|undefined = this.findDrawer(drawername);\n    if (drawer !== undefined) {\n      drawer.contents.push({name, item, visible});\n      this.signalChange();\n    } else {\n      throw Error(\"Couldn't find drawer \"+drawername);\n    }\n  }\n\n  setItemVisible(name : string, drawername: string, visible: boolean) {\n    var drawer: DrawerType|undefined = this.findDrawer(drawername);\n    if (drawer === undefined) return;\n\n    drawer.contents.forEach(element => {\n      if (element.name == name) {\n        if (element.visible !== visible) {\n          element.visible = visible;\n          this.signalChange();\n        }\n      }\n    });\n  }\n\n  setActiveDrawer(name: string) {\n    console.log(\"setActiveDrawer(\", name, \")\")\n    console.log(\"After setActiveDrawer: \", this)\n    this.state.currentdrawer = name;\n    this.signalChange();\n  }\n\n  removeItem(name : string, drawername: string) {\n    var drawer: DrawerType|undefined = this.findDrawer(drawername);\n    if (drawer !== undefined) {\n      drawer.contents = drawer.contents.filter( (val, ind, arr) => { return val.name !== name } );\n      this.signalChange();\n    }\n  }\n}","import struct from \"@aksel/structjs\";\nimport { BLE, I_BLEUpdateCallback, T_FullResponseOption } from \"./BLE\";\nimport { T_ErrorDesc, T_Update, T_UpdateGATTNotify, T_Base64String } from \"./MessageMaker\";\nimport { SimpleOption, SuccessOption } from \"../Option\";\nimport { decode } from \"base64-arraybuffer\";\n\nexport enum CharAddr {\n  Versions        = \"0000a001-0000-1000-8000-00805f9b34fb\", // A R    Versions See T_Versions\n  RequestedState  = \"0000a002-0000-1000-8000-00805f9b34fb\", // B RW   RequestedState See T_RequestedState\n  SetTime         = \"0000a003-0000-1000-8000-00805f9b34fb\", // C RW   SetTime Set current time\n  ShotDirectory   = \"0000a004-0000-1000-8000-00805f9b34fb\", // D R    ShotDirectory View shot directory\n  ReadFromMMR     = \"0000a005-0000-1000-8000-00805f9b34fb\", // E RW   ReadFromMMR Read bytes from data mapped into the memory mapped region.\n  WriteToMMR      = \"0000a006-0000-1000-8000-00805f9b34fb\", // F W    WriteToMMR Write bytes to memory mapped region\n  ShotMapRequest  = \"0000a007-0000-1000-8000-00805f9b34fb\", // G W    ShotMapRequest Map a shot so that it may be read/written\n  DeleteShotRange = \"0000a008-0000-1000-8000-00805f9b34fb\", // H W    DeleteShotRange Delete l shots in the range given\n  FWMapRequest    = \"0000a009-0000-1000-8000-00805f9b34fb\", // I W    FWMapRequest Map a firmware image into MMR. Cannot be done with the boot image\n  Temperatures    = \"0000a00a-0000-1000-8000-00805f9b34fb\", // J R    Temperatures See T_Temperatures\n  ShotSettings    = \"0000a00b-0000-1000-8000-00805f9b34fb\", // K RW   ShotSettings See T_ShotSettings\n  Deprecated      = \"0000a00c-0000-1000-8000-00805f9b34fb\", // L RW   Deprecated Was T_ShotDesc. Now deprecated.\n  ShotSample      = \"0000a00d-0000-1000-8000-00805f9b34fb\", // M R    ShotSample Use to monitor a running shot. See T_ShotSample\n  StateInfo       = \"0000a00e-0000-1000-8000-00805f9b34fb\", // N R    StateInfo The current state of the DE1\n  HeaderWrite     = \"0000a00f-0000-1000-8000-00805f9b34fb\", // O RW   HeaderWrite Use this to change a header in the current shot description\n  FrameWrite      = \"0000a010-0000-1000-8000-00805f9b34fb\", // P RW   FrameWrite Use this to change a single frame in the current shot description\n  WaterLevels     = \"0000a011-0000-1000-8000-00805f9b34fb\", // Q RW   WaterLevels Use this to adjust and read water level settings\n  Calibration     = \"0000a012-0000-1000-8000-00805f9b34fb\", // R RW   Calibration Use this to adjust and read calibration  \n}\n\nexport enum CharLen {\n  Versions = 12,\n  FWMapRequest = 7\n}\n\n// Look up \"structjs\" to see how these struct format strings work.\n// See: https://github.com/lyngklip/structjs\n// Basically, it's an implementation of python struct for JS and TS\nconst Struct_U24P0 = struct('>BBB')\nexport function toU24P0( v : number) : Buffer {\n  const hi  = (v >> 16) & 0xFF\n  const mid = (v >> 8 ) & 0xFF\n  const lo  = (v      ) & 0xFF\n  return Struct_U24P0.pack(hi, mid, lo)\n}\n\nconst Struct_datatostr = struct('>16s')\nconst Struct_MMRWrite = struct('>B3B16s')\nexport function make_MMRWrite(data: ArrayBufferLike, address : number) {\n  const hi  = (address >> 16) & 0xFF\n  const mid = (address >> 8 ) & 0xFF\n  const lo  = (address      ) & 0xFF  \n  var dstr = Struct_datatostr.unpack(data)[0]\n  return Struct_MMRWrite.pack(data.byteLength, hi, mid, lo, dstr)\n}\n\nconst Struct_FWMapRequest = struct('>HBB3B')\nexport function make_FWMapRequest( WindowInc : number = 0, FWToErase : number = 0, FWToMap : number = 0, FirstError : number = 0) : Buffer {\n  const hi  = (FirstError >> 16) & 0xFF\n  const mid = (FirstError >> 8 ) & 0xFF\n  const lo  = (FirstError      ) & 0xFF  \n  return Struct_FWMapRequest.pack(WindowInc, FWToErase, FWToMap, hi, mid, lo)\n}\n\nexport type T_FWMapRequest_Fields = {\n  WindowIncrement : number,\n  FWToErase : number,\n  FWToMap   : number,\n  FirstError: number\n}\n\nexport function parse_FWMapRequest( data : T_Base64String ) : T_FWMapRequest_Fields {\n  const bindata = decode(data)\n  const [WindowIncrement, FWToErase, FWToMap, FirstError] = Struct_FWMapRequest.unpack(bindata)\n  return { WindowIncrement, FWToErase, FWToMap, FirstError }\n}\n\nvar LastFWMRUpdate : T_Update|null = null;\n\nconst FWMRCallback : I_BLEUpdateCallback = (update : T_Update) : boolean => {\n  console.log(\"FWMRCallback: \", update);\n  LastFWMRUpdate = update;\n  return true;\n}\n\nexport async function check_FWMapRequest( ble: BLE, mac : string ) : Promise<SimpleOption<T_FWMapRequest_Fields>> {\n  var resp = LastFWMRUpdate\n  if (resp) {\n    if (resp.update == \"GATTNotify\") {\n      var notify = resp as T_UpdateGATTNotify;\n      return { success : true, result: parse_FWMapRequest(notify.results.Data) };\n    }\n  }\n\n  return { success : false }\n}\n\nexport async function write_FWMapRequest( ble : BLE, \n                                          mac : string, \n                                          WindowInc : number = 0, \n                                          FWToErase : number = 0, \n                                          FWToMap : number = 0, \n                                          FirstError : number = 0\n                                        ) : Promise<T_FullResponseOption> {\n  return await ble.requestAsyncGATTWrite(mac, CharAddr.FWMapRequest, make_FWMapRequest(WindowInc, FWToErase, FWToMap, FirstError), true)\n}\n\nexport async function write_MMR(ble: BLE, mac: string, data: ArrayBufferLike, address : number): Promise<T_FullResponseOption> {\n  return await ble.requestAsyncGATTWrite(mac, CharAddr.WriteToMMR, make_MMRWrite(data, address), true)\n}\n\nfunction sleep(ms : number) {\n  return new Promise(resolve => setTimeout(resolve, ms));\n}\n\n\nexport async function pushImage( ble: BLE, mac: string, data : ArrayBuffer ) : Promise<SuccessOption<T_ErrorDesc>> {\n  var so_mrf : SimpleOption<T_FWMapRequest_Fields>\n  var fro : T_FullResponseOption;\n\n  LastFWMRUpdate = null;\n\n  fro =  await ble.requestAsyncGATTSetNotify(mac, CharAddr.FWMapRequest, true, FWMRCallback)\n  if (!fro.success) return fro;\n  \n  var response = await write_FWMapRequest(ble, mac, 0, 1, 1, 0)\n  if (!response.success) return response;\n\n  // fro = await ble.requestAsyncGATTRead(mac, CharAddr.Versions, CharLen.Versions)\n  // if (!fro.success) return fro;\n\n  var cnt = 0;\n  so_mrf = await check_FWMapRequest(ble, mac)\n  \n  while ((cnt<10) && (!so_mrf.success)) {\n    await sleep(1000)\n    cnt += 1\n    so_mrf = await check_FWMapRequest(ble, mac)\n  }\n\n  console.log(\"Erased\")\n  \n  cnt = 0\n  var chunk = data.slice(cnt, cnt+16)  // Apparently slice returns an empty array for out of bounds indexes\n  while (chunk.byteLength > 0) {\n    var writeresp = await write_MMR(ble, mac, chunk, cnt)\n    if (!writeresp.success) {\n      console.log(\"Something went wrong during firmware upload. GATT MMR write reported: \"+writeresp.error)\n      return writeresp\n    }\n\n    console.log('Wrote %d bytes to %08x', chunk.byteLength, cnt)\n    cnt += chunk.byteLength\n    var chunk = data.slice(cnt, cnt+16)  // Apparently slice returns an empty array for out of bounds indexes    \n  }\n\n  return { success: true }\n}\n\nexport async function pollForError(ble: BLE, mac: string, nexterror = false): Promise<SimpleOption<number>> {\n  var eaddr;\n  if (nexterror) {\n    eaddr = 0xFFFFFE\n  } else {\n    eaddr = 0xFFFFFF\n  }\n\n  LastFWMRUpdate = null;\n\n  var wresp = await write_FWMapRequest(ble, mac, 0, 0, 1, eaddr)\n  if (!wresp.success) return wresp\n\n  var resp = await check_FWMapRequest(ble, mac)\n\n  var cnt = 0\n  while ((cnt<10) && (!resp.success)) {\n    console.log(\"%4d Waiting for check error response...\", cnt)\n    await sleep(1000)\n\n    resp = await check_FWMapRequest(ble, mac)\n    cnt += 1\n  }\n\n  if (resp.success) {\n    return { success : true, result: resp.result.FirstError }\n  }\n\n  return { success : false }\n}\n\nexport async function upload_Firmware(ble: BLE, mac: string, data: ArrayBuffer): Promise<SuccessOption<T_ErrorDesc>> {\n  var resp = await pushImage(ble, mac, data)\n  if (!resp) return resp;\n\n  var ferr = await pollForError(ble, mac, false)\n  if (!ferr.success) return { success: false, error: { eid: 1, errmsg: \"Timed out during FWMapRequest polling\"} }\n\n  if (ferr.result != 0xFFFFFD) {\n      // Image needs fixing\n      console.log(\"Error reported at offset: %08X\", ferr.result)\n      ferr = await pollForError(ble, mac, true)\n      if (!ferr.success) return { success: false, error: { eid: 1, errmsg: \"Timed out during FWMapRequest polling\"} }\n\n\n      console.log(\"Next error at: %08X\", ferr.result)\n      ferr = await pollForError(ble, mac, true)\n      if (!ferr.success) return { success: false, error: { eid: 1, errmsg: \"Timed out during FWMapRequest polling\"} }\n\n\n      console.log(\"Next error at: %08X\", ferr.result)\n      ferr = await pollForError(ble, mac, true)\n      if (!ferr.success) return { success: false, error: { eid: 1, errmsg: \"Timed out during FWMapRequest polling\"} }\n\n      console.log(\"Next error at: %08X\", ferr.result)\n\n  }\n\n  return { success: true }\n}\n/*\n  if (ferr != 0xFFFFFD):\n      # Image needs fixing\n      print(\"Error reported at offset: %08X\" % ferr)\n      ferr = self.pollForError(nexterror=True)\n      print(\"Next error at: %08X\" % ferr)\n      ferr = self.pollForError(nexterror=True)\n      print(\"Next error at: %08X\" % ferr)\n      ferr = self.pollForError(nexterror=True)\n      print(\"Next error at: %08X\" % ferr)\n      # self.pushImage(fname)\n    else:\n      print(\"Image is good\")\n      # self.pushImage(fname)\n\n*/\n\n/*\n def pollForError(self, nexterror=False):\n    if nexterror:\n      eaddr = 0xFFFFFE\n    else:\n      eaddr = 0xFFFFFF\n\n    write_FWMapRequest(self.FWMapRequest, 0, 0, 1, eaddr, True)\n\n    resp = read_FWMapRequest(self.FWMapRequest)\n    cnt = 0\n    while resp.FirstError == eaddr:\n      #print( \"%4s Waiting for checkerror response...\" % cnt, end=\"\\r\" )\n      time.sleep(1)\n      resp = read_FWMapRequest(self.FWMapRequest)\n    print()\n    return resp.FirstError\n*/\n\n/*\ndef pushImage(self, fname):  \n    #sys.exit(0)\n    write_FWMapRequest(self.FWMapRequest, FWToErase=1, FWToMap=1, withResponse=True)\n    \n    cnt = 0\n    while read_FWMapRequest(self.FWMapRequest).FWToErase:\n      print( \"%4s Waiting for flash to erase...\" % cnt, end=\"\\r\" )\n      time.sleep(1)\n      cnt += 1\n      \n    print( \"\\nErased\")\n    #sys.exit(0)\n    fwfile = open(fname, 'rb')\n    data = fwfile.read(16)\n    cnt = 0\n    while (len(data) > 0):\n      try:\n        write_FWWriteToMMR(self.FWWriteToMMR, data, cnt, withResponse=((cnt % 1024) == 0))\n      except BTLEException as err:\n        print()\n        print('BLE error: ', err)\n        traceback.print_exc()\n        break\n        \n      cnt += len(data)\n      print(\"Wrote {} bytes\".format(cnt), end='\\r')\n      data = fwfile.read(16)\n    \n    # Do a read of something so that we'll sleep until the BLE queue is flushed\n    read_FWMapRequest(self.FWMapRequest).FWToErase\n\n    print(\"\\nAll done!\");    \n    print(\"Wrote {} bytes\".format(cnt))\n\n*/","import { Button, ButtonGroup } from \"@mui/material\";\nimport React from \"react\";\n\nfunction buildFileSelector(){\n  const fileSelector = document.createElement('input');\n  fileSelector.setAttribute('type', 'file');\n  //fileSelector.setAttribute('multiple', 'multiple');\n  return fileSelector;\n}\n\nexport type SelectionCallback = {\n  (filename : FileList | null) : void\n}\n\ninterface MyProps {\n  onchange : SelectionCallback\n}\n \ninterface MyState {\n  files    : FileList | null\n  onchange : SelectionCallback\n}\n\n\nexport class FileSelector extends React.Component<MyProps, MyState> {\n  fileSelector : HTMLInputElement | undefined;\n\n  constructor(props : MyProps) {\n    super(props)\n    this.state = {\n      files    : null,\n      onchange : props.onchange\n    }\n  }\n\n  componentDidMount(){\n    this.fileSelector = buildFileSelector();\n    this.fileSelector.addEventListener(\"change\", this.selectionChanged);  \n  }\n  \n  handleFileSelect : React.MouseEventHandler<HTMLButtonElement> = (event: React.MouseEvent<HTMLButtonElement, MouseEvent>) => {\n    event.preventDefault();\n    if (this.fileSelector) {\n      this.fileSelector.click();\n    }\n  }\n  \n  selectionChanged = (event : any) => {\n    console.log(\"selectionChanged event: \" + event)\n    if (!event?.target?.files) return;\n    \n    this.state.onchange(event.target.files)\n    this.setState({ files : event.target.files })\n  }\n\n  render(){\n    return (\n      <div>\n      <Button variant=\"contained\" onClick={this.handleFileSelect}>Select file</Button>        \n      </div>\n    )\n  }\n}\n","import * as React from 'react';\nimport PropTypes from 'prop-types';\nimport LinearProgress from '@mui/material/LinearProgress';\nimport Typography from '@mui/material/Typography';\nimport Box from '@mui/material/Box';\n\nexport function LinearProgressWithLabel(props) {\n  return (\n    <Box sx={{ display: 'flex', alignItems: 'center' }}>\n      <Box sx={{ width: '100%', mr: 1 }}>\n        <LinearProgress variant=\"determinate\" {...props} />\n      </Box>\n      <Box sx={{ minWidth: 35 }}>\n        <Typography variant=\"body2\" color=\"text.secondary\">{`${Math.round(\n          props.value,\n        )}%`}</Typography>\n      </Box>\n    </Box>\n  );\n}\n\n// LinearProgressWithLabel.propTypes = {\n//   /**\n//    * The value of the progress indicator for the determinate and buffer variants.\n//    * Value between 0 and 100.\n//    */\n//   value: PropTypes.number.isRequired,\n// };\n\n// export default function LinearWithValueLabel() {\n//   const [progress, setProgress] = React.useState(10);\n\n//   React.useEffect(() => {\n//     const timer = setInterval(() => {\n//       setProgress((prevProgress) => (prevProgress >= 100 ? 10 : prevProgress + 10));\n//     }, 800);\n//     return () => {\n//       clearInterval(timer);\n//     };\n//   }, []);\n\n//   return (\n//     <Box sx={{ width: '100%' }}>\n//       <LinearProgressWithLabel value={progress} />\n//     </Box>\n//   );\n// }","import * as React from 'react';\nimport PropTypes from 'prop-types';\nimport Typography from '@mui/material/Typography';\n\nfunction Title(props) {\n  return (\n    <Typography component=\"h2\" variant=\"h6\" color=\"primary\" gutterBottom>\n      {props.children}\n    </Typography>\n  );\n}\n\nTitle.propTypes = {\n  children: PropTypes.node,\n};\n\nexport default Title;\n","import { Typography } from '@mui/material';\nimport React from 'react';\nimport { AppController } from '../../controllers/AppController';\nimport KeyStore from '../../models/KeyStore';\nimport { FileSelector, SelectionCallback } from '../FileSelector'\nimport { LinearProgressWithLabel } from '../LinearProgressWithLabel';\nimport Title from '../Title';\nexport type T_UpdaterStates = \"WaitForFile\" | \"Uploading\" | \"Done\";\n\nexport interface UpdaterProps {  \n  mac  : string,\n  name : string\n}\n \nexport interface UpdaterState {\n  step : T_UpdaterStates,\n  mac  : string,\n  name : string,\n  progress : number\n}\n\n\nexport class Updater extends React.Component<UpdaterProps, UpdaterState> {\n  constructor(props : UpdaterProps) {\n    super(props);\n    this.state = {\n      step: 'WaitForFile',\n      mac: props.mac,\n      name: props.name,\n      progress: 0\n    };\n  }\n\n  setFileList: SelectionCallback = (file: FileList|null) => {\n    KeyStore.getInstance().updateKey(\"Updater\", \"firmwarefile\", file)\n    AppController.getInstance().sendEventToSM( { type: 'EV_FirmwareSelected' })\n  }\n\n  showState() {\n    switch (this.state.step) {\n      case 'WaitForFile':\n        return 'Please select a file to upload.'\n      break;\n\n      case 'Uploading':\n        return 'Firmware update in progress. Please do not disturb the DE1.'\n      break;\n\n      case 'Done':\n        return 'Firmware update complete.'\n      break;\n          \n      default:\n        break;\n    }\n  }\n  // We want to show the current status: Connecting, uploading, disconnecting, done.\n  // Also want a progress bar.\n  render() {\n    return (\n      <React.Fragment>\n        <Title>Update Firmware</Title>\n        <Typography component=\"h4\" color=\"primary\">\n        {this.showState()}\n        </Typography>\n        <LinearProgressWithLabel value={0} />\n        <FileSelector onchange={this.setFileList}></FileSelector>\n      </React.Fragment>\n    )\n  }\n}","import { BLE, I_ConnectionStateCallback } from \"./BLE\";\nimport { T_ScanResult, T_Request, MessageMaker, T_ConnectionStateNotify } from \"./MessageMaker\";\nimport { DashboardController } from \"./DashboardController\";\nimport { E_Status, KeyStore } from \"../models/KeyStore\";\nimport { WSState } from \"./WSClient\";\nimport { MMRAddr } from \"./MMRList\";\nimport { DebugLogListItem } from \"../views/Dashboard/listItems\";\nimport { upload_Firmware } from \"./DE1Utils\";\nimport { Updater } from \"../views/Updater\";\n\nexport interface I_SM_Event {\n  type : T_AppMachineEvent;\n}\n\n// export type I_Promised<T> = Promise<T | undefined>;\n\nexport interface I_SM_State_Fn<T> {\n  (newtransition: boolean) : Promise<T | null>;\n}\n\nclass AsyncSimpleSM<EventType, StateType> {  \n  CurrentState : StateType;   // The current state of the machine\n  LastState : StateType; // The last state of the machine\n  EventQ : EventType[] = [];  // The queue of events to be processed\n  Transition = false;         // Transition is true if a transition has occured.\n\n  StateCode : Map<StateType, I_SM_State_Fn<StateType>> = new Map<StateType, I_SM_State_Fn<StateType>>();\n\n  sendEventToSM = (event : EventType) => {\n    console.log(\"sendEventToSM: Adding event \", event)\n    this.EventQ.push(event);\n  }\n\n  getEvent = () : EventType | undefined => {\n    return this.EventQ.shift()\n  }\n\n  // Override this to see transitions\n  onTransition = () => {};\n\n  _needToEvalSM = () : boolean => {\n    return this.Transition || this.EventQ.length > 0;\n  }\n\n  /**\n   * Evaluate the state machine.\n   * \n   * States are functions that return the new state to go to, or null to indicate that nothing should be done.\n   * They are responsible for call entry and exit actions when a state is being entered or exited.\n   * If a state returns itself as the target that means the state is looping back on itself, and the entry actions should be executed.\n   * If a state returns null that means that we are still in this state, and no transitions have occurred\n   */\n  evalSM = async () => {\n    do {\n      // Keep running until there are no more transitions or events\n      if (this.Transition) {\n        this.onTransition();\n      }\n      const statecode = this.StateCode.get(this.CurrentState);\n      if (statecode === undefined) {\n        console.log(`evalSM: No function for the current state ${this.CurrentState}`)\n        throw new Error(`evalSM: No function for the current state ${this.CurrentState}`)\n      } else {\n        const nextstate = await statecode(this.Transition);\n        if (nextstate !== null) {\n          this.LastState = this.CurrentState;\n          this.CurrentState = nextstate;\n          this.Transition = true;\n        } else {\n          this.Transition = false;\n        }\n      }  \n    } while (this._needToEvalSM());\n  }\n\n  // Call this after contruction of a derived class to set up your\n  // mapping of state names to state functions.\n  setStateCode(states : Map<StateType, I_SM_State_Fn<StateType>>) {\n    this.StateCode = states;\n  }\n\n  constructor(initialstate : StateType) {\n    this.CurrentState = initialstate;\n    this.LastState = initialstate;\n    this.Transition = true;\n  }\n}\n\n/**\n * This is where the meat of the app lives.\n * \n * The AppController coordinates everything else to present the app UI.\n * \n * The idea is that things that create HTML live in /views/*.tsx, things that control\n * behaviour live in /controllers/*.ts, and they should communicate with each other using the\n * KeyStore singleton.\n */\n\nexport type T_AppMachineEvent = \"EV_WSReady\"   | \n                                \"EV_ScanDone\"  | \n                                \"EV_ReqScan\"   | \n                                \"EV_Connected\"  | \n                                \"EV_SelectFirmware\"   | \n                                \"EV_FirmwareSelected\" |\n                                \"EV_ReadLog\"          | \n                                \"EV_ReqDisconnect\"    | \n                                \"EV_FirmwareUpdated\"  | \n                                \"EV_LogRead\"          | \n                                \"EV_Disconnected\";\nexport type T_AppMachineState = \"Init\" | \n                                \"ConnectWSC\" | \n                                \"StartBLEScan\" | \n                                \"SelectDE1\" | \n                                \"ShowMenu\" | \n                                \"ReadLog\" | \n                                \"DoFirmwareSelect\" | \n                                \"DoFirmwareUpdate\" | \n                                \"Disconnect\" | \n                                \"Error\";\n \nfunction makeEvent(ev : T_AppMachineEvent) {\n  return { type : ev };\n}\n\ntype T_Connection = {\n  name : string,\n  mac  : string\n}\n\nexport class AppController extends AsyncSimpleSM<I_SM_Event, T_AppMachineState>{\n  // @ts-expect-error\n  private static instance : AppController = AppController.instance || new AppController();\n  static BLE0 = new BLE(\"BLE0\", \"ws://192.168.68.67:8765\")\n  // static BLE0 = new BLE(\"BLE0\", \"ws://127.0.0.1:8765\")\n  public static getInstance() {\n      return AppController.instance;\n  }\n\n  dashcontroller = new DashboardController();\n  MM   : MessageMaker = new MessageMaker();\n  CurrentConnection : T_Connection | null = null;\n  DebugLogList : DebugLogListItem[] = [];\n\n  _updateReadyStatus = ( ready : boolean ) => {\n    if (ready) {\n      this.sendEventToSM({type : \"EV_WSReady\"});\n    } else {\n      this.sendEventToSM({type : \"EV_Disconnected\"});\n    }\n  }\n\n  A_StartBLEScan = () => {\n    console.log(\"AppMachine: A_StartBLEScan\");\n    const scancb = (done: boolean, entry : T_ScanResult) => {\n      if (done) {\n        this.sendEventToSM({type: \"EV_ScanDone\"});\n      }\n    }\n    AppController.BLE0.requestScanWithCallbacks(3, scancb);\n  }\n\n  A_ShowMenu = () => {};\n\n  A_HideMenu = () => {};\n\n  A_ShowBLEScan = () => {\n    this.dashcontroller.setActiveDrawer(\"Devices\");\n  };\n\n  A_HideBLEScan = () => {};\n\n  A_DoFirmwareUpdate = async () => {\n    const filelist = KeyStore.getInstance().readKey(\"Updater\", \"firmwarefile\") as FileList|null;\n    if (!filelist || !this.CurrentConnection) return;\n\n    const filedata = await filelist[0].arrayBuffer()\n    console.log(\"this.CurrentConnection:\", this.CurrentConnection)\n    const res = await upload_Firmware(AppController.BLE0, this.CurrentConnection.mac, filedata);\n    if (res.success) {\n      console.log(\"Firmware upload succeeded\")\n    } else {\n      console.log(\"Firmware upload failed: \", res.error)\n    }\n\n  };\n\n  _readLEUInt32(buf : Buffer, offset : number = 0) : number {\n    var arrbuff = Uint8Array.from(buf).buffer;\n    var dv = new DataView(arrbuff, offset);\n    return dv.getUint32(0, true);\n  }\n\n  \n  wait = (ms : number) => {\n    return new Promise((r, j)=>setTimeout(r, ms))\n  }\n\n  A_ReadLog = async () => {\n    if (!this.CurrentConnection) {\n      return;\n    }\n    const mac = this.CurrentConnection.mac\n\n    var fro = await AppController.BLE0.setUpForMMRReads(mac);\n    if (!fro.success) {\n      console.log(\"A_ReadLog: Cound not enable MMR reads\")\n      return\n    }\n    \n    console.log(\"Starting debug log read\");\n    const loglenresp = await AppController.BLE0.requestAsyncMMRRead(mac, MMRAddr.DebugLen, 0);\n    console.log(\"A_ReadLog: \", loglenresp);\n    const loglen = this._readLEUInt32(loglenresp.payload, 0);\n    console.log(\"A_ReadLog: Log length is\", loglen);\n    if (loglen > 4096) {\n      throw new Error(`Loglen of ${loglen} is out of range`);\n    }\n    if (loglen === 0) {\n      return;\n    }\n\n    var resultarray = new Uint8Array(loglen);\n    var pos = 0;\n    while (pos < loglen) {\n      console.log(`A_ReadLog: Reading at offset ${pos} out of ${loglen}`);\n      try {\n        var dataresp = await AppController.BLE0.requestAsyncMMRRead(mac, MMRAddr.DebugBuffer+pos, 3); // Read 16 bytes (16 >> 2)-1 = 3        \n        resultarray.set(Array.from(dataresp.payload), pos);\n        KeyStore.getInstance().updateKey(\"AppController\", \"debuglogprogress\", pos*100.0/loglen)\n      } catch (error) {\n        console.log(error);        \n      }\n      pos += 16;\n      // if ((pos % 1024) === 0) {\n      //    await this.wait(1000);\n      // }\n    }\n    await AppController.BLE0.requestAsyncMMRRead(mac, MMRAddr.DebugConfig, 0);\n\n    var logstr : string = \"\";\n    logstr += String.fromCharCode(...resultarray);      \n    KeyStore.getInstance().updateKey('AppController', 'debuglog', logstr);\n    this.DebugLogList.push({ name: (new Date()).toJSON(), log: logstr })\n    KeyStore.getInstance().updateKey('AppController', 'debugloglist', this.DebugLogList, true);\n\n    console.log(\"Debug log: \", logstr);\n\n  };\n\n  /*\n  def write_FWMapRequest(ctic, WindowIncrement=0, FWToErase=0, FWToMap=0, FirstError=0, withResponse=True):\n  data = struct.pack('>HBB3s', WindowIncrement, FWToErase, FWToMap, toU24P0(FirstError))\n  ctic.write(data, withResponse=withResponse)\n  */\n\n  A_SendDisconnect = () => {};\n\n  requestConnect = (name: string, mac : string) => {\n    // Used by Devices view to tell us the addr to connect to\n    const conncb : I_ConnectionStateCallback = (request : T_Request, update : T_ConnectionStateNotify) : boolean => {\n      if (update.CState === \"CONNECTED\") {\n        this.CurrentConnection = { name, mac };\n        this.sendEventToSM({type: \"EV_Connected\"});\n      }\n\n      if (update.CState === \"CANCELLED\" || update.CState === \"DISCONNECTED\") {\n        this.CurrentConnection = null;\n        this.sendEventToSM({type: \"EV_Disconnected\"}); \n      }\n      return false;\n    }\n\n    AppController.BLE0.requestGATTConnect(mac, conncb);\n  }\n\n\n  S_Init : I_SM_State_Fn<T_AppMachineState> = async (newtransition) => {\n    AppController.BLE0.registerForReadyUpdates(this._updateReadyStatus);\n    AppController.getInstance().dashcontroller.setActiveDrawer(\"Devices\")\n    return \"ConnectWSC\";\n  }\n\n  S_ConnectWSC : I_SM_State_Fn<T_AppMachineState> = async (newtransition) => {\n    if (newtransition) {\n      // If WSC is already connected, then no need to wait for a connection.\n      if (AppController.BLE0.WSC.getReadyState() == WebSocket.OPEN) {\n        // WebSocket is connected. Skip to next state.\n        return \"StartBLEScan\";\n      }\n    }\n    var nextstate : T_AppMachineState | null = null;\n    const ev = this.getEvent()\n    if (ev) {\n      switch (ev.type) {\n        case \"EV_WSReady\":\n          nextstate =  \"StartBLEScan\";\n          break;\n\n        case \"EV_Disconnected\":\n          nextstate = \"Init\";\n          break;  \n        \n        default:\n          // Illegal event?\n          console.log(\"Unexpected event in S_ConnectWSC: \", ev)\n          nextstate =  \"Init\"\n          break;\n      }\n    }\n\n    return nextstate;\n  }\n\n  S_StartBLEScan : I_SM_State_Fn<T_AppMachineState> = async (newtransition) => {\n    if (newtransition) {\n      this.dashcontroller.setActiveDrawer(\"Devices\");\n      this.A_StartBLEScan();\n      AppController.getInstance().dashcontroller.setItemVisible(\"Devices\", \"Devices\", true);\n      return null;\n    }\n\n    var nextstate : T_AppMachineState | null = null;\n    const ev = this.getEvent()\n    if (ev) {\n      switch (ev.type) {\n        case \"EV_ScanDone\":\n          nextstate = \"SelectDE1\"\n          break;\n\n        case \"EV_Disconnected\":\n          nextstate = \"Init\";\n          break;  \n        \n        default:\n          console.log(\"Unexpected event in S_StartBLEScan: \", ev)\n          // nextstate = \"Init\"\n          break;\n      }\n    }\n\n    return nextstate;\n  }\n\n  S_SelectDE1 : I_SM_State_Fn<T_AppMachineState> = async (newtransition) => {\n    var nextstate : T_AppMachineState | null = null;\n    const ev = this.getEvent()\n    if (ev) {\n      switch (ev.type) {\n        case \"EV_Connected\":\n          nextstate = \"ShowMenu\"\n          break;\n      \n        case \"EV_ReqScan\":\n          nextstate = \"StartBLEScan\";\n          break;\n\n        case \"EV_Disconnected\":\n          nextstate = \"Init\";\n          break;  \n\n        default:\n          console.log(\"Unexpected event in S_SelectDE1: \", ev)\n          // nextstate = \"Init\"\n          break;\n      }\n    }\n    \n    return nextstate;\n  }\n\n  S_ShowMenu : I_SM_State_Fn<T_AppMachineState> = async (newtransition) => { \n    if (newtransition) {\n      // Hide selection menu\n      // Show User Menu\n      AppController.getInstance().dashcontroller.setItemVisible(\"UserMenu\", \"Devices\", true);\n      AppController.getInstance().dashcontroller.setItemVisible(\"Devices\", \"Devices\", false);\n    }\n    var nextstate : T_AppMachineState | null = null;\n    const ev = this.getEvent()\n    if (ev) {\n      switch (ev.type) {\n        case \"EV_ReadLog\":\n          nextstate = \"ReadLog\";\n        break;\n        case \"EV_SelectFirmware\":\n          nextstate = \"DoFirmwareSelect\";\n        break;\n        case \"EV_ReqDisconnect\":\n          nextstate = \"Disconnect\";\n        break;\n        case \"EV_Disconnected\":\n          nextstate = \"Init\";\n        break;\n            \n        default:\n          break;\n      }\n    }\n\n    if (nextstate !== null) {\n      // We are exiting this state, so do any actions required\n      AppController.getInstance().dashcontroller.setItemVisible(\"UserMenu\", \"Devices\", false);\n    }\n\n    return nextstate;\n  }\n\n  S_ReadLog : I_SM_State_Fn<T_AppMachineState> = async (newtransition) => { \n    if (newtransition) {\n      AppController.getInstance().dashcontroller.setItemVisible(\"DE1Info\", \"Devices\", true);\n\n      await this.A_ReadLog()\n    }\n    var nextstate : T_AppMachineState | null = null;\n    const ev = this.getEvent()\n    if (ev) {\n      switch (ev.type) {\n        case \"EV_Disconnected\":\n          nextstate = \"Init\";\n        break;\n            \n        default:\n          break;\n      }\n    }\n\n    if (nextstate !== null) {\n      // We are exiting this state; do any actions required\n      \n    }\n\n    return nextstate;\n  }\n\n  S_DoFirmwareSelect : I_SM_State_Fn<T_AppMachineState> = async (newtransition) => {\n    if (newtransition) {\n      // Start another async task that does firmware update\n      const dc = AppController.getInstance().dashcontroller\n\n      if (this.CurrentConnection) {\n        dc.addItem(\"Updater\", \"Firmware\", <Updater mac={this.CurrentConnection.mac} name={this.CurrentConnection.name} />, true);\n        dc.setActiveDrawer(\"Firmware\")\n      }\n    }\n    \n    var nextstate : T_AppMachineState | null = null;\n    const ev = this.getEvent()\n    if (ev) {\n      switch (ev.type) {\n        case \"EV_Disconnected\":\n          nextstate = \"Init\";\n        break;\n\n        case \"EV_FirmwareSelected\":\n          nextstate = \"DoFirmwareUpdate\"\n        break;\n            \n        default:\n          break;\n      }\n    }\n\n    if (nextstate !== null) {\n      // We are exiting this state; do any actions required\n      \n    }\n\n    return nextstate;\n  }\n\n  S_DoFirmwareUpdate : I_SM_State_Fn<T_AppMachineState> = async (newtransition) => {\n    if (newtransition) {\n      await this.A_DoFirmwareUpdate()\n    }\n    \n    var nextstate : T_AppMachineState | null = null;\n    const ev = this.getEvent()\n    if (ev) {\n      switch (ev.type) {\n        case \"EV_Disconnected\":\n          nextstate = \"Init\";\n        break;\n\n        default:\n          break;\n      }\n    }\n\n    if (nextstate !== null) {\n      // We are exiting this state; do any actions required\n      \n    }\n\n    return nextstate;\n  }\n\n  S_Disconnect : I_SM_State_Fn<T_AppMachineState> = async (newtransition) => {\n    if (newtransition) {\n      console.log(\"AppMachine S_Disconnect() requesting disconnect from \", this.CurrentConnection)\n      if (this.CurrentConnection) {\n        const discb : I_ConnectionStateCallback = (request : T_Request, response : T_ConnectionStateNotify) : boolean => {\n          console.log(\"S_Disconnect: Disconnect: \", response)\n          this.sendEventToSM({type: \"EV_Disconnected\"});\n          return false;\n        }\n        AppController.BLE0.requestGATTDisconnect(this.CurrentConnection.mac, discb);\n      }\n    }\n    var nextstate : T_AppMachineState | null = null;\n    const ev = this.getEvent()\n    if (ev) {\n      switch (ev.type) {\n        case \"EV_Disconnected\":\n          nextstate = \"Init\";\n        break;\n            \n        default:\n          break;\n      }\n    }\n\n    if (nextstate !== null) {\n      // We are exiting this state; do any actions required\n      \n    }\n\n    return nextstate;\n  }\n\n  S_Error : I_SM_State_Fn<T_AppMachineState> = async (newtransition) => { return null }\n\n  StateMap: Map<T_AppMachineState, I_SM_State_Fn<T_AppMachineState>> = new Map<T_AppMachineState, I_SM_State_Fn<T_AppMachineState>>(\n    [\n      [\"Init\", this.S_Init],\n      [\"ConnectWSC\", this.S_ConnectWSC],\n      [\"StartBLEScan\", this.S_StartBLEScan],\n      [\"SelectDE1\", this.S_SelectDE1],\n      [\"ShowMenu\", this.S_ShowMenu],\n      [\"ReadLog\", this.S_ReadLog],\n      [\"DoFirmwareSelect\", this.S_DoFirmwareSelect],\n      [\"DoFirmwareUpdate\", this.S_DoFirmwareUpdate],\n      [\"Disconnect\", this.S_Disconnect],\n      [\"Error\", this.S_Error]\n    ]);\n\n  constructor() {\n    super(\"Init\"); // \"Init\" is the initial state of the machine.\n    this.setStateCode(this.StateMap);\n    KeyStore.getInstance().updateKey(\"AppController\", \"AppMachineState\", this.CurrentState)\n  }\n\n  onTransition = () => {\n    console.log(`AppMachine state transition: ${this.LastState} -> ${this.CurrentState}`);\n    KeyStore.getInstance().updateKey(\"AppController\", \"AppMachineState\", this.CurrentState)\n  }\n\n  _wschange = (owner: string, key: string, status: E_Status, before: any, after: any) => {\n    // after is a WSState\n    const state = after as WSState;\n    if (state === WebSocket.OPEN) {\n      this.sendEventToSM({type : \"EV_WSReady\"});\n    };\n\n    if (state === WebSocket.CLOSED) {\n      this.sendEventToSM({type: \"EV_Disconnected\"});\n    }\n  }\n\n\n  run = async () => {\n    try {\n      await this.evalSM();      \n    } catch (error) {\n      console.log(\"Exception in AppMachine.run(): \", error)\n    }\n    setTimeout(this.run, 10);\n  }\n}\n","import MuiDrawer from \"@mui/material/Drawer\";\nimport MuiAppBar from \"@mui/material/AppBar\";\nimport { styled } from \"@mui/material/styles\";\n\n\nconst drawerWidth = 240;\n \nexport const OurAppBar = styled(MuiAppBar, {\n                 shouldForwardProp: (prop) => prop !== \"open\",\n               })<{open: boolean}>\n(({ theme, open }) => ({\n  zIndex: theme.zIndex.drawer + 1,\n  transition: theme.transitions.create([\"width\", \"margin\"], {\n    easing: theme.transitions.easing.sharp,\n    duration: theme.transitions.duration.leavingScreen,\n  }),\n  ...(open && {\n    marginLeft: drawerWidth,\n    width: `calc(100% - ${drawerWidth}px)`,\n    transition: theme.transitions.create([\"width\", \"margin\"], {\n      easing: theme.transitions.easing.sharp,\n      duration: theme.transitions.duration.enteringScreen,\n    }),\n  }),\n}));\n\nexport const OurDrawer = styled(MuiDrawer, {\n  shouldForwardProp: (prop) => prop !== \"open\",\n})(({ theme, open }) => ({\n  \"& .MuiDrawer-paper\": {\n    position: \"relative\",\n    whiteSpace: \"nowrap\",\n    width: drawerWidth,\n    transition: theme.transitions.create(\"width\", {\n      easing: theme.transitions.easing.sharp,\n      duration: theme.transitions.duration.enteringScreen,\n    }),\n    boxSizing: \"border-box\",\n    ...(!open && {\n      overflowX: \"hidden\",\n      transition: theme.transitions.create(\"width\", {\n        easing: theme.transitions.easing.sharp,\n        duration: theme.transitions.duration.leavingScreen,\n      }),\n      width: theme.spacing(7),\n      [theme.breakpoints.up(\"sm\")]: {\n        width: theme.spacing(9),\n      },\n    }),\n  },\n}));\n","import ListItem from '@mui/material/ListItem';\nimport ListItemIcon from '@mui/material/ListItemIcon';\nimport ListItemText from '@mui/material/ListItemText';\nimport ListSubheader from '@mui/material/ListSubheader';\nimport AssignmentIcon from '@mui/icons-material/Assignment';\nimport React, { Component, ReactNode } from 'react';\nimport KeyStore, { E_Status } from '../../models/KeyStore';\nimport { DownloadForOfflineSharp } from '@mui/icons-material';\nimport { ListItemButton } from '@mui/material';\n\nexport type DebugLogListItem = {\n  name : string,\n  log  : string\n}\n\ntype DebugLogListItemState = {\n  header : string,\n  items : DebugLogListItem[]\n}\n\ntype DebugLogListItemProps = {\n  header : string\n}\n\n\nfunction download(filename : string, text : string) {\n  var element = document.createElement('a');\n  element.setAttribute('href', 'data:text/plain;charset=utf-8,' + encodeURIComponent(text));\n  element.setAttribute('download', filename);\n\n  element.style.display = 'none';\n  document.body.appendChild(element);\n\n  element.click();\n\n  document.body.removeChild(element);\n}\n\n// Start file download.\n// download(\"hello.txt\",\"This is the content of my file :)\");\n\n\nfunction makeDebugLogListItem(text : DebugLogListItem) : JSX.Element {\n  return (\n      <ListItemButton onClick={() => {download(text.name+\".txt\", text.log)}}>\n      <ListItemIcon>\n      <DownloadForOfflineSharp />\n      </ListItemIcon>\n      <ListItemText primaryTypographyProps={{fontSize: 'x-small'}} primary={text.name} />\n      </ListItemButton>\n  )\n}\n\nexport class DebugLogList extends React.Component<DebugLogListItemProps, DebugLogListItemState> {\n  state : DebugLogListItemState;\n  constructor(props : DebugLogListItemProps) {\n    super(props);\n    this.state = {\n      header : props.header,\n      items  : []\n    }\n  }\n\n  componentDidMount = () => {\n    KeyStore.getInstance().requestNotifyOnChanged(\"AppController\", \"debugloglist\", this._logsupdated)\n  }\n\n  componentWillUnmount = () => {\n    KeyStore.getInstance().cancelNotify(\"AppController\", \"debugloglist\", this._logsupdated)\n  }\n\n  _logsupdated = (owner: string, key: string, status: E_Status, before: any, after: any) => {\n    this.setState({items : after})\n  }\n\n  render = () : ReactNode => {\n    return (\n      <div>\n          { (this.state.items.length > 0) && <ListSubheader inset>{this.state.header}</ListSubheader> }\n          { this.state.items.map( makeDebugLogListItem ) }\n      </div>\n    )\n  }\n}\n","import * as React from \"react\";\nimport { createTheme, ThemeProvider } from \"@mui/material/styles\";\nimport CssBaseline from \"@mui/material/CssBaseline\";\nimport Box from \"@mui/material/Box\";\nimport Toolbar from \"@mui/material/Toolbar\";\nimport List from \"@mui/material/List\";\nimport Typography from \"@mui/material/Typography\";\nimport Divider from \"@mui/material/Divider\";\nimport IconButton from \"@mui/material/IconButton\";\n// import Badge from \"@mui/material/Badge\";\nimport Container from \"@mui/material/Container\";\nimport Grid from \"@mui/material/Grid\";\nimport Paper from \"@mui/material/Paper\";\nimport MenuIcon from \"@mui/icons-material/Menu\";\nimport ChevronLeftIcon from \"@mui/icons-material/ChevronLeft\";\n// import NotificationsIcon from '@mui/icons-material/Notifications';\nimport { OurAppBar, OurDrawer } from \"../AppBar\";\n\nimport ListItem from '@mui/material/ListItem';\nimport ListItemIcon from '@mui/material/ListItemIcon';\nimport ListItemText from '@mui/material/ListItemText';\nimport { DashboardController, DrawerType } from \"../../controllers/DashboardController\";\nimport { Copyright } from \"@mui/icons-material\";\nimport { DebugLogList } from \"./listItems\"\n\nexport const mdTheme = createTheme();\n\ntype DashboardState = {\n  open : boolean,\n  changecount : number\n}\n\ntype DashboardProps = {\n  controller: DashboardController;\n}\n\nfunction wrapInPaper(item: JSX.Element) {\n  return (\n    <Paper\n      sx={{\n        p: 2,\n        display: \"flex\",\n        flexDirection: \"column\",\n      }}\n    >\n      {item}\n    </Paper>\n  );\n}\n\nfunction wrapInGridCell(name: string, item : JSX.Element) {\n  console.log(\"wrapInGridCell: \", name)\n  return (\n    <Grid item key={name} xs={12}>\n      {item}\n    </Grid>\n  )\n}\n\nexport class Dashboard extends React.Component<DashboardProps, DashboardState> {\n  constructor(props : DashboardProps) {\n    super(props);\n    this.state = {\n      open: true,\n      changecount: 0\n    }\n  }\n\n  toggleDrawer = () => {\n    this.setState({ open: !this.state.open })\n  }\n  \n  componentDidMount() {\n    this.props.controller.setUIElement(this);\n  }\n\n  dcontent() {\n    console.log(\"dcontent() state: \", this)\n    let current = this.props.controller.getCurrentDrawer()\n    let activedrawer = this.props.controller.drawers.find((val : DrawerType) => {\n      console.log(\"Compare: \", val.name, current, val.name === current)\n      return val.name === current;\n    });\n\n    if (activedrawer !== undefined) {\n      return activedrawer.contents.map((val) => {\n        if (val.visible) { \n          return wrapInGridCell(val.name, wrapInPaper(val.item))\n        } else {\n          return null;\n        }\n      })\n    } else {\n      return wrapInGridCell(\"Oops\", wrapInPaper(<p>Oops. Nothing to show.</p>))\n    }\n  }\n\n  drawerContent() {\n    return (\n      <React.Fragment>\n        {this.dcontent()}\n      </React.Fragment>\n    )\n  }\n\n  onDrawerClick(name: string) {\n    this.props.controller.setActiveDrawer(name);\n  }\n\n  makeListItem = (details: DrawerType) : JSX.Element => {\n    console.log(\"MakeListItem: \", details.name)\n    return (\n      <ListItem button key={details.name} onClick={() => { this.onDrawerClick(details.name)} }>\n        <ListItemIcon>\n          {details.draweritem}\n        </ListItemIcon>\n        <ListItemText primary={details.name} />\n      </ListItem>\n    )\n  }\n  \n  mainListItems() : JSX.Element {\n    let arr = Array.from(this.props.controller.drawers);\n    return <div>\n      {arr.map(this.makeListItem)}\n    </div>\n  }\n\n  render() { \n    // This is basically boilerplate for the side drawer.\n    return (\n      <ThemeProvider theme={mdTheme}>\n        <Box sx={{ display: \"flex\" }}>\n          <CssBaseline />\n          <OurAppBar position=\"absolute\" open={this.state.open}>\n            <Toolbar\n              sx={{\n                pr: \"24px\", // keep right padding when drawer closed\n              }}\n            >\n              <IconButton\n                edge=\"start\"\n                color=\"inherit\"\n                aria-label=\"open drawer\"\n                onClick={this.toggleDrawer}\n                sx={{\n                  marginRight: \"36px\",\n                  ...(this.state.open && { display: \"none\" }),\n                }}\n              >\n                <MenuIcon />\n              </IconButton>\n              <Typography\n                component=\"h1\"\n                variant=\"h6\"\n                color=\"inherit\"\n                noWrap\n                sx={{ flexGrow: 1 }}\n              >\n                {this.props.controller.getCurrentDrawer()}\n              </Typography>\n              {/* <IconButton color=\"inherit\">\n                <Badge badgeContent={4} color=\"secondary\">\n                  <NotificationsIcon />\n                </Badge>\n              </IconButton> */}\n            </Toolbar>\n          </OurAppBar>\n          <OurDrawer variant=\"permanent\" open={this.state.open}>\n            <Toolbar\n              sx={{\n                display: \"flex\",\n                alignItems: \"center\",\n                justifyContent: \"flex-end\",\n                px: [1],\n              }}\n            >\n              <IconButton onClick={this.toggleDrawer}>\n                <ChevronLeftIcon />\n              </IconButton>\n            </Toolbar>\n            <Divider />\n            <List>{this.mainListItems()}</List>\n            <Divider />\n            <List><DebugLogList header=\"Recent Debug Logs\"/></List>\n          </OurDrawer>\n          <Box\n            component=\"main\"\n            sx={{\n              backgroundColor: (theme) =>\n                theme.palette.mode === \"light\"\n                  ? theme.palette.grey[100]\n                  : theme.palette.grey[900],\n              flexGrow: 1,\n              height: \"100vh\",\n              overflow: \"auto\",\n            }}\n          >\n            <Toolbar />\n            <Container maxWidth=\"lg\" sx={{ mt: 4, mb: 4 }}>\n              <Grid container spacing={3}>\n                {this.drawerContent()}\n              </Grid>\n              <Copyright sx={{ pt: 4 }} />\n            </Container>\n          </Box>\n        </Box>\n      </ThemeProvider>\n    );\n  }\n}\n","//import * as React from 'react';\nimport React, { Component } from 'react';\nimport Table from '@mui/material/Table';\nimport TableBody from '@mui/material/TableBody';\nimport TableCell from '@mui/material/TableCell';\nimport TableHead from '@mui/material/TableHead';\nimport TableRow from '@mui/material/TableRow';\nimport Title from '../Title';\nimport { E_Status, NotifyCallbackType } from '../../models/KeyStore';\nimport KeyStore from '../../models/KeyStore';\nimport { I_BLEResponseCallback, DeviceMap, I_ConnectionStateCallback } from '../../controllers/BLE';\nimport { T_IncomingMsg, T_Request, T_ConnectionState, T_ConnectionStateNotify } from \"../../controllers/MessageMaker\";\nimport { ConnectWithoutContactSharp, DoNotDisturbOnSharp, RadarSharp, BluetoothConnectedSharp } from '@mui/icons-material';\nimport { Box, Button, CircularProgress, IconButton, Stack } from '@mui/material';\nimport { AppController, T_AppMachineState } from '../../controllers/AppController';\nimport \"./Devices.css\";\nimport { timeStamp } from 'console';\n\ntype RowDataType = {\n  addr : string,\n  name : string,\n  cstate : T_ConnectionState,\n}\n\nfunction row_compare(a: RowDataType, b: RowDataType): number {\n  if (a.addr === b.addr) {\n    return 0;\n  }\n  return (a.addr > b.addr) ? -1 : 1\n}\n\ntype MyState = {\n  rows : RowDataType[];\n  allowConnect : boolean;\n  connecting : boolean\n}\n\ntype MyProps = {\n  name: string\n}\n\n// Generate Machine Data\nexport class Devices extends Component<MyProps, MyState> {\n  state : MyState;\n  constructor(props : MyProps) {\n    super(props);\n    console.log(\"Devices()\");\n    console.log(\"props:\", props);\n    this.state = {\n      rows : [this.createData(\"\",\"\", \"DISCONNECTED\")],\n      allowConnect : false,\n      connecting : false\n    }\n    console.log(\"this.state:\", this.state);\n  }\n\n  componentDidMount() {\n    KeyStore.getInstance().requestNotifyOnChanged(this.props.name, \"DeviceSet\", this.onDeviceChange)\n    KeyStore.getInstance().requestNotifyOnChanged(\"AppController\", \"AppMachineState\", this.onStateChange)\n    this.setState({rows : this.rowsFromStore(), allowConnect: false, connecting: false})\n  }\n\n  componentWillUnmount() {\n    KeyStore.getInstance().cancelNotify(this.props.name, \"DeviceSet\", this.onDeviceChange)\n    KeyStore.getInstance().cancelNotify(\"AppController\", \"AppMachineState\", this.onStateChange)\n  }\n\n  onStateChange : NotifyCallbackType = (owner, key, status, before, after : T_AppMachineState): void  => {\n    console.log(\"onStateChange:\", owner, key, status, before, after)\n\n    if (after === \"SelectDE1\") {\n      this.setState({allowConnect : true, connecting : false})\n    } else {\n      this.setState({allowConnect : false, connecting : false})\n    }\n  }\n\n  onDeviceChange : NotifyCallbackType = (owner, key, status, before, after : DeviceMap): void  => {\n    console.log(\"onDeviceChange:\", owner, key, status, before, after)\n\n    // \"after\" will be the DeviceSet\n    if ((status === E_Status.Changed) || (status === E_Status.Added)) {\n      let darr = [];\n      for (var device of after.keys()) {\n        const dev = after.get(device);\n        if (dev) {\n          darr.push(this.createData(dev.MAC, dev.Name, dev.State));\n        }\n      } \n      darr.sort(row_compare);\n      this.setState({ rows: darr });\n    }\n  }\n\n  rowsFromStore(): RowDataType[] {\n    let darr = [];\n    let devices : DeviceMap = KeyStore.getInstance().readKey(this.props.name, \"DeviceSet\");\n    if (devices !== undefined) {\n      for (var device of devices.keys()) {\n        const dev = devices.get(device);\n        if (dev) {\n          darr.push(this.createData(dev.MAC, dev.Name, dev.State));\n        }\n      }\n      darr.sort(row_compare);  \n    } else {\n      darr.push(this.createData(\"-\", \"-\", \"DISCONNECTED\"));\n    }\n    //this.setState({ rows: darr });\n    return darr;\n  }\n\n  addDevice(addr: string, name: string, cstate: T_ConnectionState) {\n    this.state.rows.push(this.createData(addr, name, cstate))\n  }\n\n  createData(addr: string, name: string, cstate : T_ConnectionState): RowDataType {\n    return { addr, name, cstate };\n  }\n\n  preventDefault(event: any) {\n    event.preventDefault();\n  }\n\n  disconnect(name : string, addr : string) {\n    console.log(\"Device onClick() disconnect from \", name, addr)\n    const discb : I_ConnectionStateCallback = (request : T_Request, constate : T_ConnectionStateNotify) : boolean => {\n      console.log(\"Devices: Disconnect: \", constate)\n      return false;\n    }\n    AppController.BLE0.requestGATTDisconnect(addr, discb);\n  }\n  \n  connect(name : string, addr : string) {\n    console.log(\"Device onClick() connect to \", name, addr)\n    AppController.getInstance().requestConnect(name, addr)\n    this.setState({connecting : true})\n  }\n\n  connectIcon(row : RowDataType): JSX.Element {\n    var buttonstyle={width: '24px', height: '24px', margin: '5px'};\n    \n\n    if (row.name === \"DE1\") {\n      if (row.cstate !== \"CONNECTED\") {\n        if (this.state.allowConnect && !this.state.connecting) {\n          // A button that allows connecting\n          return (\n            <TableCell>\n              <div className=\"cell-button\">\n                <IconButton onClick={ () => {this.connect(row.name, row.addr)} }>\n                  <ConnectWithoutContactSharp />\n                </IconButton>\n              </div>\n            </TableCell>\n          )    \n        } else {\n          return (\n            // A button that shows we are not ready to connect or that we are connecting\n            <TableCell>\n              <div className=\"cell-button\" >\n                <CircularProgress style={buttonstyle}/>\n              </div>\n            </TableCell>\n          )\n        }\n      } else {\n        return (\n          // A button that shows we are connected\n          <TableCell>\n            <div className=\"cell-button\">\n              <IconButton onClick={ () => {this.disconnect(row.name, row.addr)} } style={buttonstyle}>\n                <BluetoothConnectedSharp/>\n              </IconButton>\n            </div>    \n          </TableCell>\n        )  \n      }\n    } else {\n      return (\n        // A button that says we can't connect\n        <TableCell>\n          <div className=\"cell-button\">        \n            <IconButton style={buttonstyle}>\n              <DoNotDisturbOnSharp />\n            </IconButton>\n          </div>\n        </TableCell>\n      )\n    }\n  }\n\n  reqScan() {\n    AppController.getInstance().sendEventToSM({type: \"EV_ReqScan\"});\n  }\n\n  render() { \n    var scan;\n    \n    if (this.state.allowConnect) {\n      scan = (\n        <Stack sx={{pt:2}} direction='row' className='scan-box'>\n          <Button variant=\"contained\" size=\"medium\" startIcon={<RadarSharp />} onClick={this.reqScan}>Scan</Button>\n        </Stack>\n      )\n    } else {\n      scan = (\n        <Stack sx={{pt:2}} direction='row' className='scan-box'>\n          <Button disabled variant=\"contained\" size=\"medium\" startIcon={<RadarSharp />} onClick={this.reqScan}>Scan</Button>\n        </Stack>\n      )\n    };\n\n    return (\n      <div className='device-card'>\n        <Title>Seen Devices</Title>\n        <Table size=\"small\">\n          <TableHead>\n            <TableRow>\n              <TableCell>BLE Name</TableCell>\n              <TableCell>BLE Address</TableCell>\n              <TableCell>Connect</TableCell>\n            </TableRow>\n          </TableHead>\n          <TableBody>\n            {this.state.rows.map((row) => (\n              <TableRow key={row.addr}>\n                <TableCell>{row.name}</TableCell>\n                <TableCell>{row.addr}</TableCell>\n                {this.connectIcon(row)}\n              </TableRow>\n            ))}\n          </TableBody>\n        </Table>\n        {scan}\n      </div> \n    )\n  }\n}\n \n// export default Devices;\n","import React, { Component } from 'react';\nimport Title from './Title';\nimport KeyStore, { NotifyCallbackType } from '../models/KeyStore';\n\ntype WSProps = {\n  name : string\n}\n\ntype WSState = {\n  url : string,\n  readyState : number\n}\n\nclass WSClient extends Component<WSProps, WSState> {\n  constructor(props : WSProps) {\n    super(props);\n    console.log(\"Props:\", props);\n    this.state = {\n      url : \"Unset\",\n      readyState : 3\n    }  \n  }\n\n  componentDidMount() {\n    KeyStore.getInstance().requestNotifyOnChanged(this.props.name, \"url\", this.onControllerChange)\n    KeyStore.getInstance().requestNotifyOnChanged(this.props.name, \"readyState\", this.onControllerChange)\n    this.updateStateFromStore();\n  }\n\n  componentWillUnmount() {\n    console.log(\"WSClient.componentWillUnmount\");\n    KeyStore.getInstance().cancelNotify(this.props.name, \"url\", this.onControllerChange);\n    KeyStore.getInstance().cancelNotify(this.props.name, \"readyState\", this.onControllerChange);\n  }\n\n  onControllerChange : NotifyCallbackType = (owner, key, status, before, after) => {\n    console.log(\"onControllerChange:\", owner, key, status, before, after)\n    this.updateStateFromStore();\n  }\n\n  updateStateFromStore() {\n    this.setState({ \n      url : KeyStore.getInstance().readKey(this.props.name, \"url\"),\n      readyState : KeyStore.getInstance().readKey(this.props.name, \"readyState\")\n    });\n  }\n  render() {\n    return <React.Fragment>\n      <Title>WebSocket Connection</Title>\n      <ul>\n        <li> URL: {this.state.url} </li>\n        <li> Status: {this.state.readyState === 1 ? \"Connected\" : \"Disconnected\"}</li>\n      </ul>\n    </React.Fragment>\n  }\n}\n\nexport default WSClient;","import * as React from \"react\";\nimport { AppController } from \"../../controllers/AppController\";\nimport { T_ConnectionState } from \"../../controllers/MessageMaker\";\nimport KeyStore, { E_Status, NotifyCallbackType } from \"../../models/KeyStore\";\nimport { LinearProgressWithLabel } from \"../LinearProgressWithLabel\";\nimport Title from '../Title';\n\ntype T_DE1InfoState = {\n  cstate : T_ConnectionState\n  progress : number,\n  updatecount : number\n}\n\ntype T_DE1InfoProps = {\n  mac : string,\n}\n\nexport class DE1Info extends React.Component<T_DE1InfoProps, T_DE1InfoState> {\n  LogLines : string[] = [];\n\n  constructor(props : T_DE1InfoProps) {\n    super(props);\n    this.state = {\n      cstate : AppController.BLE0.SeenDevices.get(props.mac)?.State || \"DISCONNECTED\",\n      progress : 0.0,\n      updatecount : 0\n    }\n  }\n\n  componentDidMount() {\n    KeyStore.getInstance().requestNotifyOnChanged(\"AppController\", \"debuglog\", this._updateLog)\n    KeyStore.getInstance().requestNotifyOnChanged(\"AppController\", \"debuglogprogress\", this._updateProgress)    \n  }\n\n  componentWillUnmount() {\n    KeyStore.getInstance().cancelNotify(\"AppController\", \"debuglog\", this._updateLog)\n    KeyStore.getInstance().cancelNotify(\"AppController\", \"debuglogprogress\", this._updateProgress)\n  }\n\n  updateLog = () => {\n    var log = KeyStore.getInstance().readKey(\"AppController\", \"debuglog\")\n    if (log) {\n      this.LogLines = log.split(\"\\n\")\n    }\n  }\n\n  _updateProgress : NotifyCallbackType = (owner: string, key: string, status: E_Status, before: any, after: any) => {\n    const percentage : number = after;\n    this.setState({progress : percentage})\n  }\n\n  _updateLog : NotifyCallbackType = (owner: string, key: string, status: E_Status, before: any, after: any) => {\n    this.updateLog();\n    this.setState({updatecount : (this.state.updatecount + 1)})\n  }\n  \n  render() {\n    this.updateLog()\n    return (\n      <div className='de1info-card'>\n      <Title>Debug log</Title>\n      { (this.LogLines.length == 0) && <LinearProgressWithLabel value={this.state.progress}></LinearProgressWithLabel> }\n      <p className='debuglog' style={{fontFamily : 'monospace', fontSize : 'x-small'}}>\n        { this.LogLines.map( (val:string) => {\n          return <React.Fragment>{val} <br></br></React.Fragment>\n        })\n      }\n      </p>\n      </div>\n    )\n  }\n}","import { Box, Button, Stack } from '@mui/material';\nimport React, { Component } from 'react';\nimport { AppController } from '../../controllers/AppController';\nimport \"./UserMenu.css\";\n\ntype MyState = {\n}\n\ntype MyProps = {\n}\n\n// Generate Machine Data\nexport class UserMenu extends Component<MyProps, MyState> {\n  state : MyState;\n  constructor(props : MyProps) {\n    super(props);\n    this.state = {\n    }\n    console.log(\"UserMenu constructor state:\", this.state);\n  }\n\n  makeOnclick = (item : number) => {\n    return ( () => {\n      switch (item) {\n        case 0:\n          AppController.getInstance().sendEventToSM({type : 'EV_ReadLog'});\n          break;\n        case 1:\n          AppController.getInstance().sendEventToSM({type : 'EV_SelectFirmware'});\n          break;\n        case 2:\n          AppController.getInstance().sendEventToSM({type : 'EV_ReqDisconnect'});\n          break;\n      \n        default:\n          break;\n      }\n    })\n  }\n\n\n  render() { \n    return (\n      <Stack className=\"user-menu\" sx={{spacing: 1}}>\n        <Button variant=\"contained\" onClick={this.makeOnclick(0)}>Read Debug Log</Button>\n        <Button variant=\"contained\" onClick={this.makeOnclick(1)}>Update Firmware</Button>\n        <Button variant=\"contained\" onClick={this.makeOnclick(2)}>Disconnect</Button>\n      </Stack>\n    )\n  }\n}\n","import React from \"react\";\nimport { AppController } from \"./controllers/AppController\";\nimport { Dashboard } from \"./views/Dashboard\";\nimport DashboardIcon from '@mui/icons-material/Dashboard';\nimport BluetoothSearchingIcon from '@mui/icons-material/BluetoothSearching';\nimport { Devices } from \"./views/Devices\"\nimport { DrawerContentType } from \"./controllers/DashboardController\";\nimport WSClient from \"./views/WSClient\";\nimport { HardwareSharp, TableRowsSharp } from \"@mui/icons-material\";\nimport { DE1Info } from \"./views/DE1Info\"\nimport { UserMenu } from \"./views/UserMenu\";\n\ninterface AppProps {\n  \n}\n \ninterface AppState {\n}\n\ntype T_DrawerContent = [string, JSX.Element, boolean]\ntype T_DrawerItem = [string, any, T_DrawerContent[]];\n\n/**\n * ADD AND REMOVE DASHBOARD CATEGORIES AND CARDS HERE\n *                  |\n *                  |\n *                  V\n */\nconst draweritems: T_DrawerItem[] = [\n  [\"Firmware\", <HardwareSharp />,\n    [\n      [\"WSClient\", <WSClient name=\"wsc_BLE0\"/>, true]\n    ]\n  ],\n  [\"Status\", <DashboardIcon />,\n    [\n      [\"WSClient\", <WSClient name=\"wsc_BLE0\"/>, true]\n    ]\n  ],\n  [\"Devices\", <BluetoothSearchingIcon />, \n    [\n      [\"UserMenu\", <UserMenu />, false],\n      [\"DE1Info\", <DE1Info mac=\"\"/>, false],\n      [\"Devices\", <Devices name=\"BLE0\"/>, true],\n      [\"WSClient\", <WSClient name=\"wsc_BLE0\"/>, true],\n    ]\n  ]\n  // [\"MMRs\", <TableRowsSharp />, [[\"MMRs\", <MMR_UI />, false]]\n]\n\n/**\n * This is the view for the App.\n * \n * ie. There should be no code here that controls how the app behaves. The code here is\n * to show the app to the user.\n * \n */\nclass App extends React.Component<AppProps, AppState> {\n  // All control code lives in the App Controller and its children.\n\n  constructor(props: AppProps) {\n    super(props);\n    console.log(\"props: \", props)\n  }\n\n  componentDidMount() {\n    console.log(\"cdm: \", this);\n    draweritems.forEach((item: T_DrawerItem) => {AppController.getInstance().dashcontroller.addDrawer(item[0], item[1], this.toDrawerContentType(item[2]))});\n    AppController.getInstance().dashcontroller.setActiveDrawer(\"Devices\");\n  }\n \n  toDrawerContentType(inputarr : T_DrawerContent[]): DrawerContentType[] {\n    return inputarr.map((val) => {\n      return { name: val[0], item: val[1], visible: val[2] };\n    })\n  }\n\n  render() { \n    return (\n      <Dashboard controller={AppController.getInstance().dashcontroller}/>\n    );\n  }\n}\n \nexport default App;","import ReactDOM from 'react-dom';\nimport CssBaseline from '@mui/material/CssBaseline';\nimport { ThemeProvider } from '@mui/material/styles';\nimport theme from './theme';\nimport App from './App';\nimport { AppController } from './controllers/AppController';\n\nReactDOM.render(\n  <ThemeProvider theme={theme}>\n    {/* CssBaseline kickstart an elegant, consistent, and simple baseline to build upon. */}\n    <CssBaseline />\n    <App />\n  </ThemeProvider>,\n  document.querySelector('#root'),\n);\n\nAppController.getInstance().run();\n","/**\n * This class is intended to help with a proper Model - View - Controller implementation, with a small twist.\n * \n * Rather than the Controller driving both the View and the Model, the Controller only drives the Model, and the\n * Model drives the View via callbacks.\n * \n * The View will notified when something it has registered to monitor, changes in the keystore, so it can update.\n * \n * This way there is one central store of all data, and views are completely decoupled. Also, we don't encode data\n * relationships, parentage, etc in the structure of the code building the views, and the relationships between\n * controllers is no longer constrained by UI or OOP concerns.\n */\n\nexport enum E_Status {\n  Added,\n  Changed,\n  Deleted\n}\nexport type NotifyCallbackType = (owner: string, key: string, status: E_Status, before: any, after: any) => void;\n\ntype StoreItemType = Map<string, any>\ntype OwnerDictType = Map<string, StoreItemType>\ntype NotifyItemType = Map<string, Set<NotifyCallbackType>>;\ntype NotifyOwnerDictType = Map<string, NotifyItemType>\n\n/**\n * KeyStore is intended to be used as a singleton!\n * Grab your instance from KeyStore.getInstance()\n * \n * \n * There are 'listeners' which are notified when keys are changed, and 'broadcasters' that update a key. There are\n * also 'owners' that created a key.\n * \n * How to use the KeyStore, if you are registering to just listen:\n * \n * 1. When your component mounts/is created, call requestNotifyOnChanged() for keys you want to monitor.\n *    You DO NOT have to register a notify in order to be able to read a key.\n * 2. Every change of a key generates a callback, so be cautious about doing too much work on a callback.\n *    Ideally, rather use a key that is updated sparingly, when major state changes occur, and only notify on that.\n * 3. When your component unmounts/disappears, be sure to cancelNotify() on all keys.\n * \n * If you 'own' some keys:\n * 1. When your component mounts/is created, call updateKey() to create the key.\n * 2. Update keys as required using updateKey().\n * 3. When your component is going away, either delKey() each key, or just call delOwnerKeys() to remove\n *    all the keys you own. Listeners will be notified when a key is deleted.\n * \n * If you are broadcasting on keys:\n * 1. Call updateKey() to update a key. If the key data has a deep change that won't show up with a shallow\n *    compare, force an update.\n * 2. Try not to create any unintentional infinite loops by changing keys that cause you to be notified. :-)\n * \n * You can mix and match on any of the above scenarios, but for your own sanity I suggest that only the owner\n * change a key. For bidirectional communications, use two keys. Do not have multiple entities changing the\n * same key!\n */\nexport class KeyStore  {\n  // @ts-expect-error\n  private static instance : KeyStore = KeyStore.instance || new KeyStore();\n\n  constructor() {\n    console.log(\"******************** KeyStore constructor()\");\n  }\n  \n  public static getInstance(): KeyStore {\n    return KeyStore.instance;\n  }\n\n  // We store key value pairs here\n  globalkeystore : OwnerDictType = new Map<string, StoreItemType>() // dict of dicts. Outer key is owner, inner is key\n\n  // We store sets of notify functions for each key, here.\n  notifybykey : NotifyOwnerDictType = new Map<string, NotifyItemType>()  // dict[owner] of dict[key] of sets of callback functions\n\n  // Return the dict owned by ownername. Creates it if necessary.\n  _getStore(ownername: string): StoreItemType {\n    var store = this.globalkeystore.get(ownername);\n    if (!store) {\n      store = new Map<string, any>();\n      this.globalkeystore.set(ownername, store)\n    }\n    return store;\n  }\n\n  // Notify any listeners of a key having been added\n  _doNotifyAdded(owner: string, key: string, newvalue: any) {\n    const keystore = this.notifybykey.get(owner);\n    if (keystore !== undefined) {\n      const fnset = keystore.get(key);\n      if (fnset) {\n        fnset.forEach((value) => {\n          value(owner, key, E_Status.Added, null, newvalue);\n        });\n      }  \n    }\n  }\n\n  // Notifies any registered callbacks that a key has been deleted.\n  // Also deletes the callback function pointers for the key after calling them.\n  _doNotifyDeleted(owner: string, key: string, oldvalue: any) {\n    var keystore = this.notifybykey.get(owner);\n    if (keystore !== undefined) {\n      var fnset = keystore.get(key);\n      if (fnset) {\n        fnset.forEach((value) => {\n          value(owner, key, E_Status.Deleted, oldvalue, null);\n        });\n        keystore.delete(key);\n      }  \n    }\n  }\n\n  _doNotifyChanged(owner: string, key: string, oldvalue: any, newvalue: any) {\n    const keystore = this.notifybykey.get(owner);\n    if (keystore !== undefined) {\n      const fnset = keystore.get(key);\n      if (fnset) {\n        fnset.forEach((value) => {\n          value(owner, key, E_Status.Changed, oldvalue, newvalue);\n        });\n      }  \n    }\n  }\n\n  /**\n   * updateKey\n   * \n   * @param {string} ownername \n   * @param {string} key \n   * @param {*} newvalue \n   * @param {bool} forcenotify \n   * \n   * If there are any notify callbacks associated with a key, and the value changes,\n   * the callbacks will be called. This does not do deep comparison of objects,\n   * so use 'forcenotify' if necessary.\n   * \n   * NB: THIS FUNCTION SHOULD ONLY BE USED BY THE OWNER. The keystore is not supposed to be\n   * a big global variable. Owners change things, and everyone else watches.\n   */\n  updateKey(ownername: string, key: string, newvalue: any, forcenotify?: boolean) {\n    console.log(\"updateKey:\", ownername, key, newvalue, forcenotify);\n    var store = this._getStore(ownername);\n    const oldvalue = store.get(key);\n    if ((forcenotify) || (oldvalue !== newvalue)) {\n      store.set(key, newvalue);\n      this._doNotifyChanged(ownername, key, oldvalue, newvalue);\n    }\n  }\n\n  // Read key\n  readKey(ownername: string, key: string) {\n    const store = this._getStore(ownername)\n    return store.get(key);\n  }\n\n  // Delete key\n  // Also deletes any notification requests associated with the key, after\n  // calling them.\n  delKey(ownername: string, key: string) {\n    var store = this._getStore(ownername);\n    if ( store.has(key) ) {\n      let oldvalue = store.get(key);\n      this._doNotifyDeleted(ownername, key, oldvalue);  \n      store.delete(key);\n    }\n\n  }\n\n  // Delete all keys owned by owner (and their callbacks)\n  // Should be used by an owner to clean up after itself\n  delOwnerKeys(ownername: string) {\n    var store = this._getStore(ownername)\n    for(let key of Array.from(store.keys()) ) {\n      this.delKey(ownername, key)\n    }\n  }\n\n  /**\n   * requestNotifyOnChanged\n   *  \n   * @param {string} ownername \n   * @param {string} key \n   * @param {function} changedfn \n   * \n   * Add a notify callback function that will be called when a key is added, deleted, or modified.\n   * You can register for the callback before the key exists.\n   * \n   * Prototype for changedfn:\n   *  fn(owner, key, status, before, after)\n   * \n   *  owner: string identifying owner (ie. the code updating the key)\n   *  key: string identifying key\n   *  status: will be one of 'Added', 'Changed', 'Deleted'\n   *  before: null or the old value before a change\n   *  after: null or the value after a change\n   * \n   * Note that callbacks are made the instant updateStore/delKey are called,\n   * so if you only want to react after a complete operation is done,\n   * perhaps only notify on a key that can be set after all changes have been made.\n   */\n  requestNotifyOnChanged(ownername: string, key: string, changedfn: NotifyCallbackType) {\n    console.log(\"requestNotifyOnChanged:\", ownername, key)\n    if (!ownername) throw Error(\"Ownername invalid\");\n    if (!key) throw Error(\"Key invalid\");\n\n    var keystore = this.notifybykey.get(ownername);\n    if (!keystore) {\n      keystore = new Map<string, Set<NotifyCallbackType>>();\n      this.notifybykey.set(ownername, keystore);\n    }\n    let notifyset = keystore.get(key)\n    if (!notifyset) {\n      notifyset = new Set([])\n      keystore.set(key, notifyset)\n    }\n    notifyset.add(changedfn)\n  }\n\n  // Cancel the given notify for the given key\n  cancelNotify(ownername: string, key: string, fn: NotifyCallbackType) {\n    var keystore = this.notifybykey.get(ownername);\n    if (keystore !== undefined) {\n      var fnset = keystore.get(key);\n      if (fnset) fnset.delete(fn);  \n    }\n  }\n}\n \nexport default KeyStore;","/**\n * Map that stringifies the key objects in order to leverage\n * the javascript native Map and preserve key uniqueness.\n * \n * Snaffled from this stackoverflow answer, with much gratitude:\n * https://stackoverflow.com/a/56912757\n*/\n\nexport abstract class StringifyingMap<K, V> {\n  private map = new Map<string, V>();\n  private keyMap = new Map<string, K>();\n\n  has(key: K): boolean {\n      let keyString = this.stringifyKey(key);\n      return this.map.has(keyString);\n  }\n  get(key: K): V|undefined {\n      let keyString = this.stringifyKey(key);\n      return this.map.get(keyString);\n  }\n  set(key: K, value: V): StringifyingMap<K, V> {\n      let keyString = this.stringifyKey(key);\n      this.map.set(keyString, value);\n      this.keyMap.set(keyString, key);\n      return this;\n  }\n\n  /**\n   * Puts new key/value if key is absent.\n   * @param key key\n   * @param defaultValue default value factory\n   */\n  putIfAbsent(key: K, defaultValue: () => V): boolean {\n      if (!this.has(key)) {\n          let value = defaultValue();\n          this.set(key, value);\n          return true;\n      }\n      return false;\n  }\n\n  keys(): IterableIterator<K> {\n      return this.keyMap.values();\n  }\n\n  keyList(): K[] {\n      return [...this.keys()];\n  }\n\n  delete(key: K): boolean {\n      let keyString = this.stringifyKey(key);\n      let flag = this.map.delete(keyString);\n      this.keyMap.delete(keyString);\n      return flag;\n  }\n\n  clear(): void {\n      this.map.clear();\n      this.keyMap.clear();\n  }\n\n  size(): number {\n      return this.map.size;\n  }\n\n  /**\n   * Turns the `key` object to a primitive `string` for the underlying `Map`\n   * @param key key to be stringified\n   */\n  protected abstract stringifyKey(key: K): string;\n}\n\n","import { encode, decode } from \"base64-arraybuffer\";\n\nexport type T_MsgType_REQ = \"REQ\";\nexport type T_MsgType_RESP = \"RESP\";\nexport type T_MsgType_UPDATE = \"REQ\";\nexport type T_MsgType = T_MsgType_REQ | T_MsgType_RESP | T_MsgType_UPDATE;\nexport type T_ConnectionState = \"INIT\" | \"DISCONNECTED\" | \"CONNECTED\" | \"CANCELLED\";\nexport type T_ReqCommandStr = \"Scan\" | \"GATTConnect\" | \"GATTDisconnect\" | \"GATTRead\" | \"GATTSetNotify\" | \"GATTWrite\";\nexport type T_Base64String = string;\nexport type T_Request = {\n  type: T_MsgType_REQ;\n  command: T_ReqCommandStr;\n  params: any;\n  id: number;\n};\n\nexport type T_Params_Scan = {\n  Timeout: number;\n}\n\nexport type T_Params_GATTConnect = {\n  'MAC': string\n}\n\nexport type T_Params_GATTDisconnect = {\n  'MAC': string\n}\n\nexport type T_Params_GATTRead = {\n  \n}\n\nexport type T_Request_Scan = {\n  type: T_MsgType_REQ;\n  command: \"Scan\";\n  params: T_Params_Scan;\n  id: number;\n}\n\nexport type T_ErrorDesc = {\n  eid: number;\n  errmsg: string;\n};\n\nexport type T_RespNoError = {\n  eid : 0;\n  errmsg: \"\";\n}\n\nexport type T_Response = {\n  type: \"RESP\"; // T_MsgType\n  id: number;\n  error: T_ErrorDesc;\n  results: any;\n};\n\nexport type T_Results_GATTRead = {\n  Data : T_Base64String;\n}\n\nexport type T_Response_GATTRead = {\n  type: \"RESP\"; // T_MsgType\n  id: number;\n  error: T_ErrorDesc;\n  results: T_Results_GATTRead;\n};\n\n// A result from an ongoing BLE scan\n\nexport type T_ScanResult = {\n  MAC: string;\n  Name: string;\n  UUIDs: [string];\n};\n// A notify that we subscribed to has delivered some data\n\nexport type T_Results_GATTNotify = {\n  MAC: string;\n  Char: string;\n  Data: T_Base64String;\n};\n// Notification of a connection or disconnection. If id != 0, then this connection\n// state is the direct result of a connect or disconnect request.\n\nexport type T_ConnectionStateNotify = {\n  MAC: string;\n  CState: T_ConnectionState;\n  UUIDs: [string];\n};\n// Used to report any runtime errors that occurred in the server\n\nexport type T_UpdateType = \"ScanResult\" | \"GATTNotify\" | \"ConnectionState\" | \"ExecutionError\";\nexport type T_UpdateResult = T_ScanResult | T_Results_GATTNotify | T_ConnectionStateNotify | T_ErrorDesc;\nexport type T_Update = {\n  type: \"UPDATE\"; // T_MsgType\n  id: number;\n  update: T_UpdateType;\n  results: T_UpdateResult;\n};\n\nexport type T_UpdateGATTNotify = {\n  type: \"UPDATE\"; // T_MsgType\n  id: number;\n  update: \"GATTNotify\";\n  results: T_Results_GATTNotify;\n};\n\nexport type T_IncomingMsg = T_Response | T_Update;\n// Info we store in a devicemap\n\nexport type T_DeviceState = {\n  MAC: string;\n  Name: string;\n  UUIDs: [string];\n  State: T_ConnectionState;\n};\n/**\n * Class to make the various message types we'll need\n *\n * Doesn't really need to be a class, but thought it would be nice\n * to keep it all together, and I might add methods later to turn\n * on various debugging functions.\n */\n\nexport class MessageMaker {\n  makeReq(command: T_ReqCommandStr, rid: number, params: any): T_Request {\n    return {\n      type: 'REQ',\n      command: command,\n      params: params,\n      id: rid\n    };\n  }\n\n  makeScan(timeout: number, rid: number): T_Request {\n    // Scan(timeout : U32)\n    var params = {\n      Timeout: timeout\n    };\n    return this.makeReq(\"Scan\", rid, params);\n  }\n\n  makeConnect(mac: string, rid: number) {\n    const params = {\n      'MAC': mac,\n    };\n    return this.makeReq(\"GATTConnect\", rid, params);\n  }\n\n  makeDisconnect(mac: string, rid: number) {\n    const params = {\n      'MAC': mac,\n    };\n    return this.makeReq(\"GATTDisconnect\", rid, params);\n  }\n\n  makeGATTRead(mac: string, char: string, rlen: number, rid: number) {\n    const params = {\n      'MAC': mac,\n      'Char': char,\n      'Len': rlen\n    };\n    return this.makeReq(\"GATTRead\", rid, params);\n  }\n\n  makeGATTWrite(mac: string, char: string, data: ArrayBufferLike, rid: number, requireresponse : boolean) {\n    const params = {\n      'MAC': mac,\n      'Char': char,\n      'Data': encode(data),\n      'RR' : requireresponse\n    };\n    return this.makeReq(\"GATTWrite\", rid, params);\n  }\n  makeGATTSetNotify(mac: string, char: string, enable: boolean, rid: number) {\n    const params = {\n      'MAC': mac,\n      'Char': char,\n      'Enable': enable\n    };\n    return this.makeReq(\"GATTSetNotify\", rid, params);\n  }\n\n  makeIncomingMsgFromJSON(jsondata: string): T_IncomingMsg {\n    var msg = JSON.parse(jsondata);\n    if (msg.type === \"RESP\") {\n      // Response\n      let resp = msg as T_Response;\n      return resp;\n    }\n    if (msg.type === \"UPDATE\") {\n      // Update\n      return msg as T_Update;\n    }\n    throw new Error(\"Unrecognised Incoming Message\");\n  }\n\n  updateFromMsg(msg: T_IncomingMsg): T_Update {\n    if (msg.type === \"UPDATE\") {\n      return msg as T_Update;\n    }\n    throw new Error(\"Not a T_Update\");\n  }\n\n  connStateFromUpdate(msg: T_Update): T_ConnectionStateNotify {\n    if (msg.update === 'ConnectionState') {\n      return msg.results as T_ConnectionStateNotify;\n    }\n    throw new Error(\"Not a ConnectionState T_Update\");\n  }\n\n  scanResultFromUpdate(msg: T_Update): T_ScanResult {\n    if (msg.update === \"ScanResult\") {\n      return msg.results as T_ScanResult;\n    }\n    throw new Error(\"Not a T_ScanResult\");\n  }\n}\n","import { StringifyingMap } from '../components/StringifyingMap'\nimport KeyStore from '../models/KeyStore'\nimport { T_DeviceState, T_ConnectionState, T_Request, T_IncomingMsg, T_ScanResult, MessageMaker, T_Results_GATTNotify, T_Response, T_Update, T_UpdateGATTNotify, T_Base64String, T_ErrorDesc, T_ConnectionStateNotify } from './MessageMaker';\nimport { WSClientController, WSState } from './WSClient'\nimport { FullOption, SimpleOption, SuccessOption } from \"../Option\"\n\nexport class DeviceMap extends StringifyingMap<string, T_DeviceState> {\n  protected stringifyKey(key: string): string {\n      return key.toString();\n  }\n}\n\nexport class ConnMap extends StringifyingMap<string, T_ConnectionState> {\n  protected stringifyKey(key: string): string {\n      return key.toString();\n  }\n}\n\nexport type T_FullResponseOption = FullOption<T_Response, T_ErrorDesc>;\n\nexport interface I_BLEIncomingMsgCallback {\n  // Return true if more callbacks are expected.\n  // Return false to make the BLE class forget about this id and callback\n  // Forgetting to return false will leak memory\n  (request : T_Request, response : T_IncomingMsg) : boolean;\n};\n\nexport interface I_BLEResponseCallback {\n  // Return true if more callbacks are expected.\n  // Return false to make the BLE class forget about this id and callback\n  // Forgetting to return false will leak memory\n  (request : T_Request, response : T_FullResponseOption) : boolean;\n};\n\nexport interface I_BLEUpdateCallback {\n  // Return true if more callbacks are expected.\n  // Return false to make the BLE class forget about this callback\n  (update : T_Update) : boolean;\n};\n\nexport interface I_ConnectionStateCallback {\n  // Return true if more callbacks are expected.\n  // Return false to make the BLE class forget about this callback\n  (request : T_Request, update : T_ConnectionStateNotify) : boolean;\n}\n\ntype IDBundle = {\n  req : T_Request;\n  cb  : I_BLEIncomingMsgCallback;\n}\n\ntype T_NotifyKey = {\n  MAC : string,  // MAC address a notify is coming from\n  Char : string  // Characteristic that has changed\n}\n\nexport interface ScanCallbackType {\n  (done: boolean, entry : T_ScanResult) : void;\n}\n\nexport interface ReadyCallback {\n  ( ready : boolean ) : void;\n}\n\ntype MMRAddress = {\n  MAC : string,\n  Addr : number\n}\n\nexport interface MMRCallback {\n  // If success == false, then payload === null\n  ( success : boolean, mac : string, wordlen : number, addr : number, payload : Buffer|null) : void;\n}\n\ninterface MMRReadReq {\n  mac: string,\n  mmraddress : number, \n  wordlen : number, \n  callback : MMRCallback;\n}\n\ninterface MMRReadResponse {\n  mac: string,\n  mmraddress : number, \n  wordlen : number, \n  payload : Buffer\n}\n\nclass IDMap extends StringifyingMap<number, IDBundle> {\n  protected stringifyKey(key: number): string {\n    return key.toString();\n  }\n}\n\nclass NotifyMap extends StringifyingMap<T_NotifyKey, I_BLEUpdateCallback> {\n  protected stringifyKey(key: T_NotifyKey): string {\n    return key.MAC + key.Char;\n  }\n}\n\nclass MMRNotifyMap extends StringifyingMap<MMRAddress, MMRCallback> {\n  protected stringifyKey(key: MMRAddress): string {\n    return key.MAC.toString() + key.Addr.toString();\n  }\n}\n\n/**\n * Class to handle a BLE interface.\n * \n * TODO: replace all exceptions with Result from the neverthrow library\n */\nexport class BLE  {\n  SeenDevices : DeviceMap = new DeviceMap(); // Seen BLE devices\n  ConnectedDevices : ConnMap = new ConnMap(); // Devices we have a GATT connection to\n  NotifyCallbackMap : NotifyMap = new NotifyMap();\n  SentMap : IDMap = new IDMap();  // Map used to associate outgoing requests with responses\n  LastID  : number;  // Last ID used for a request. Increments and wraps around at MAX_ID\n  ReadyCallbackMap : Map<ReadyCallback, string> = new Map<ReadyCallback, string>();\n\n  MM   : MessageMaker;\n  URL  : string;\n  Name : string;\n  WSC  : WSClientController;\n  WSCName : string;\n  MMRMap : MMRNotifyMap = new MMRNotifyMap();\n  PendingMMRReads : MMRReadReq[];\n\n  MAX_ID = 1000000000;\n\n  registerForReadyUpdates(cb : ReadyCallback) {\n    this.ReadyCallbackMap.set(cb, \"\");\n  }\n\n  unregisterForReadyUpdates(cb : ReadyCallback) {\n    this.ReadyCallbackMap.delete(cb);\n  }\n\n  isBLEReady = () => {\n    return this.WSC.getReadyState() === WebSocket.OPEN;\n  }\n\n  static asUpdate(msg : T_IncomingMsg) : SimpleOption<T_Update> {\n    if (msg.type === \"UPDATE\") {\n      return { success: true, result : msg as T_Update }\n    }\n\n    return { success: false };\n  }\n\n  static asResponseOption(msg : T_IncomingMsg) : T_FullResponseOption {\n    console.log(\"asResponse: \", msg)\n    if (msg.type === \"RESP\") {\n      return { success: true, result: msg as T_Response}\n    }\n\n    return { success: false, error: msg.results as T_ErrorDesc}\n  }\n\n  // Convert a I_BLEIncomingMsgCallback to I_BLEResponseCallback\n  static _makeResponseTrampoline( callback : I_BLEResponseCallback) {\n    const trampoline = (request: T_Request, msg : T_IncomingMsg): boolean => {\n      callback(request, BLE.asResponseOption(msg))\n\n      return false;\n    }\n\n    return trampoline\n  }\n\n  _forget(id: number) {\n    if (this.SentMap.has(id)) {\n      this.SentMap.delete(id); // Forget association with this request\n    }\n  }\n\n  _sendAsJSON(thing: T_Request) {\n    console.log(\"_sendAsJSON: \", thing);\n    this.WSC.send(JSON.stringify(thing));\n  }\n\n  _onmessage = (event : MessageEvent<any>) : boolean => {\n    console.log(\"BLE._onmessage:\", event);\n    const data : T_IncomingMsg = this.MM.makeIncomingMsgFromJSON(event[\"data\"]);\n\n    // If there's a chance we could now trigger a new read, do so.\n    if (this.PendingMMRReads.length > 0) {\n      setTimeout(this._procPendingMMRReads, 0);\n    }\n    \n    if (data.id === 0) {\n      // This is an unsolicted update\n      // Usually a disconnect notification\n      console.log(\"BLE\", 'Unsolicited update: ', data);\n      return this._handleUnsolicitedUpdate(data);\n    }\n\n    const bundle = this.SentMap.get(data.id);\n    if (bundle === undefined) {\n      // We have a response for an unknown request\n      console.log(\"BLE\", 'Unknown ID in response: ', data, this.SentMap);\n      return false;\n    }\n\n    console.log(\"BLE: calling back:\", bundle, data);\n    try {\n      const keepmapping = bundle.cb(bundle.req, data);\n      if (!keepmapping) {\n        this._forget(data.id); // Forget association with this request\n      }  \n    } catch (err) {\n      console.log(\"_onmessage() callback error: \", err)\n    }\n    return false;\n  }\n\n  _onstatechange = () => {\n    console.log(\"_onstatechange: readyState:\", this.WSC.getReadyState());\n    if (this.WSC.getReadyState() === WebSocket.OPEN) {\n      // // Request a new scan when we connect to the server\n      // this.requestScanWithCallbacks(6, null);\n      this.ReadyCallbackMap.forEach( (value, key, map) => { key(true) })\n    }\n    if (this.WSC.getReadyState() === WebSocket.CLOSED) {\n      // No more devices known\n      this.reset();\n      KeyStore.getInstance().updateKey(this.Name, \"DeviceSet\", this.SeenDevices, true);\n      this.ReadyCallbackMap.forEach( (value, key, map) => { key(false) })\n    }\n  }\n\n  // Handle updates from the other side that have an id of zero.\n  // This means that they are not a direct response to a request.\n  // So, notifies and disconnections.\n  _handleUnsolicitedUpdate = (update : T_IncomingMsg) : boolean => {\n    if (update.type === \"UPDATE\") {\n      if (update.update === \"GATTNotify\") {\n        // A GATT Characteristic changed. Notify if someone cares.\n        const notify : T_Results_GATTNotify = update.results as T_Results_GATTNotify;\n        const key = { MAC : notify.MAC, Char : notify.Char } as T_NotifyKey;\n        const callback = this.NotifyCallbackMap.get(key);\n        if (callback !== undefined) {\n          callback(update);\n        }\n      }\n    }\n    return false;\n  }\n\n  /**\n   * Increment the ID we use to generate BLE packet requests\n   */\n\n  incId = () : number => {\n    let id = this.LastID + 1;\n    if (id > this.MAX_ID) {\n      this.LastID = 1\n    } else {\n      this.LastID = id;\n    }\n    return this.LastID;\n  }\n\n  /**\n   * Trigger a BLE scan.\n   * \n   * The callback will be called back multiple times, once for each device seen.\n   * \n   * If \"done\" is true, then the device information is invalid, and the scan is over\n   *\n   * @param timeout  How many seconds to scan for\n   * @param callback Function to call when we receive an update about a device during a scan. Can be null.\n   */\n  requestScanWithCallbacks(timeout: number, callback : ScanCallbackType | null) {\n    const id = this.incId();\n\n    const blecb = (request : T_Request, response : T_IncomingMsg): boolean => {\n      console.log(\"blecb\", request, response);\n      if (response.type === \"UPDATE\") {\n        const upd = this.MM.updateFromMsg(response);\n        if (upd.update === 'ScanResult') {\n          const dev : T_ScanResult = this.MM.scanResultFromUpdate(upd);\n          const cstate = this.ConnectedDevices.get(dev.MAC) || \"DISCONNECTED\"\n          const devstate : T_DeviceState = {\n            MAC : dev.MAC,\n            Name : dev.Name,\n            UUIDs : dev.UUIDs,\n            State : cstate\n          }\n          if (dev.MAC) {\n            this.SeenDevices.set(dev.MAC, devstate);\n            console.log(\"BLE\", dev);\n            KeyStore.getInstance().updateKey(this.Name, \"DeviceSet\", this.SeenDevices, true);\n            if (callback) callback(false, dev);\n            return true;\n          } else {\n            // This was our last update.\n            if (callback) callback(true, dev);     // Notify listener\n            return false; // Forget association with this request\n          }\n        }\n      }\n      // Should be impossible to get here. Should only get ScanResults\n      return false;\n    }\n\n    try {\n      const scanreq = this.MM.makeScan(timeout, id);\n      this.SentMap.set(id, {req: scanreq, cb: blecb});\n      this._sendAsJSON(scanreq);  \n    } catch (error) {\n      // I'm honestly not sure what kinds of things could go wrong here, yet.\n      // For now just log it?\n      console.log(\"Error in requestScanWithCallbacks:\", error);\n    }\n  }\n\n  /**\n   * Request a BLE scan.\n   * \n   * Returns when the scan is done. \"DeviceSet\" in the KeyStore will be up to date,\n   * or read this.Devices.\n   */\n  requestScan = async (timeout : number) => {\n    return new Promise<string>((resolve, reject) => {\n\n      const id = this.incId();\n      const blecb = (request : T_Request, response : T_IncomingMsg): boolean => {\n        if (response.type === \"UPDATE\") {\n          const upd = this.MM.updateFromMsg(response);\n          if (upd.update === 'ScanResult') {\n            const dev = this.MM.scanResultFromUpdate(upd);\n            const cstate = this.ConnectedDevices.get(dev.MAC) || \"DISCONNECTED\"\n            const devstate : T_DeviceState = {\n              MAC : dev.MAC,\n              Name : dev.Name,\n              UUIDs : dev.UUIDs,\n              State : cstate\n            }\n            if (dev.MAC) {\n              this.SeenDevices.set(dev.MAC, devstate);\n              KeyStore.getInstance().updateKey(this.Name, \"DeviceSet\", this.SeenDevices, true);\n              return true;\n            } else {\n              // This was our last update.\n              // Forget association with this request\n              resolve(\"Scan done\");\n              return false;\n            }\n          }\n        }\n        // Should be impossible to get here. Should only get ScanResults\n        console.log(\"ScanResults callback got called with bad data: \", response);\n        reject(new Error(`ScanResult callback got called with bad data: ${response}`))\n        return false;\n      }\n\n      try {\n        const scanreq = this.MM.makeScan(timeout, id);\n        this.SentMap.set(id, {req: scanreq, cb: blecb});\n        this._sendAsJSON(scanreq);  \n      } catch (error) {\n        // I'm honestly not sure what kinds of things could go wrong here, yet.\n        // For now just log it?\n        console.log(\"Error in requestScanWithCallbacks:\", error);\n        reject(new Error(\"Caught exception in requestScan\"));\n      }\n    });\n  };\n\n  // Accept a request, fill in a real ID, set up the callback map (SentMap),\n  // convert to JSON and send.\n  _sendRequest(reqtosend: T_Request, callback: I_BLEIncomingMsgCallback) {\n    const id = this.incId();\n    reqtosend.id = id;\n    this.SentMap.set(id, {req: reqtosend, cb: callback});\n    this._sendAsJSON(reqtosend);  \n  }\n\n  _updateConnState(mac : string, state : T_ConnectionState) {\n    if (state === \"CONNECTED\") {\n      this.ConnectedDevices.set(mac, state);\n    } else {\n      this.ConnectedDevices.delete(mac);\n    }\n    var devstate = this.SeenDevices.get(mac);\n    if (devstate !== undefined) {\n      devstate.State = state;\n      this.SeenDevices.set(mac, devstate);\n    } else {\n      console.log(\"BLE: Connectionstate received for a device not in SeenDevices: \", mac, state);\n    }\n\n    KeyStore.getInstance().updateKey(this.Name, \"DeviceSet\", this.SeenDevices, true)\n  }\n\n  /**\n   * Request a connection to the GATT server on a device\n   * \n   * Will return with a connection state after connection fails or succeeds, and then\n   * the callback will be forgotten.\n   * \n   * Register for unsolicited callbacks using registerForNotifies to be informed\n   * of things like disconnects.\n   * \n   * @param mac MAC address of server, eg \"20:C3:8F:E3:B6:A3\"\n   * @param callback Function to call back with the result\n   */\n  requestGATTConnect = (mac : string, callback : I_ConnectionStateCallback) => {\n    const conncb = (request: T_Request, response: T_IncomingMsg): boolean => {\n      // We proxy the callback so we can update our list of connected devices.\n      const update = this.MM.updateFromMsg(response)\n      let connstate = this.MM.connStateFromUpdate(update);\n      this._updateConnState(connstate.MAC, connstate.CState);\n      console.log(\"BLE: requestGATTConnect response:\", connstate)\n      callback(request, connstate);\n      return false;\n    }    \n    this._sendRequest(this.MM.makeConnect(mac, 0), conncb);\n  }\n\n    /**\n   * Request a disconnection from the GATT server on a device\n   * \n   * Will return with a connection state after disconnection fails or succeeds, and then\n   * the callback will be forgotten.\n   * \n   * Register for unsolicited callbacks using registerForNotifies to be informed\n   * of things like disconnects.\n   * \n   * @param mac MAC address of server, eg \"20:C3:8F:E3:B6:A3\"\n   * @param callback Function to call back with the result\n   */\n  requestGATTDisconnect = (mac : string, callback : I_ConnectionStateCallback) => {\n    const disconncb = (request: T_Request, response: T_IncomingMsg): boolean => {\n      // We proxy the callback so we can update our list of disconnected devices.\n      let connstate = this.MM.connStateFromUpdate(this.MM.updateFromMsg(response));\n      this._updateConnState(connstate.MAC, connstate.CState);\n      console.log(\"BLE: requestGATTDisconnect response:\", connstate)\n      callback(request, connstate);\n      return false;\n    }    \n    this._sendRequest(this.MM.makeDisconnect(mac, 0), disconncb);\n  }\n\n    /**\n   * Do a callback write to a GATT device\n   * \n   * @param mac MAC address\n   * @param char Characteristic to write\n   * @param data Data to write (should just be the size of the characteristic, for now)\n   * @param requireresponse Set true if Bluetooth should guarantee the delivery of the transaction (requires the other side to acknowledge the write)\n   * @param callback Callback to call with response. Return false from callback.\n   */\n     requestGATTWrite = (mac : string, char : string, data : Buffer, requireresponse: boolean, callback : I_BLEResponseCallback) => {   \n      this._sendRequest(this.MM.makeGATTWrite(mac, char, data, 0, requireresponse), BLE._makeResponseTrampoline(callback));\n    }\n\n   /**\n   * Do an async write to a GATT device\n   * \n   * @param mac MAC address\n   * @param char Characteristic to write\n   * @param data Data to write (should just be the size of the characteristic, for now)\n   * @param requireresponse Set true if Bluetooth should guarantee the delivery of the transaction (requires the other side to acknowledge the write)\n   * @returns T_IncomingMsg, which is the result of your request.\n   * \n   */\n  requestAsyncGATTWrite = async (mac : string, char : string, data : Buffer, requireresponse : boolean) : Promise<FullOption<T_Response, T_ErrorDesc>> => {\n    return new Promise<FullOption<T_Response, T_ErrorDesc>>((resolve, reject) => {\n      const blecb = (request : T_Request, msg : T_FullResponseOption): boolean => {\n        resolve(msg);\n        return false;\n      }\n\n      this.requestGATTWrite(mac, char, data, requireresponse, blecb);\n    })\n  }\n    \n  /**\n   * Do a callback read from a GATT device\n   * \n   * @param mac MAC address\n   * @param char Characteristic to read\n   * @param readlen Number of bytes to read (should just be the size of the characteristic, for now)\n   * @param callback Callback to call with response. Return false from callback.\n   */\n  requestGATTRead = (mac : string, char : string, readlen : number, callback : I_BLEResponseCallback) => {\n    this._sendRequest(this.MM.makeGATTRead(mac, char, readlen, 0), BLE._makeResponseTrampoline(callback));\n  }\n\n  /**\n   * Do an async read from a GATT device\n   * \n   * @param mac MAC address\n   * @param char Characteristic to read\n   * @param readlen Number of bytes to read (should just be the size of the characteristic, for now)\n   * @returns T_IncomingMsg, which is the result of your request.\n   */\n  requestAsyncGATTRead = async (mac : string, char : string, readlen : number) : Promise<FullOption<T_Response, T_ErrorDesc>> => {\n    return new Promise<FullOption<T_Response, T_ErrorDesc>>((resolve, reject) => {\n      const blecb = (request : T_Request, response : T_FullResponseOption): boolean => {\n        resolve(response)\n        return false;\n      }\n\n      this.requestGATTRead(mac, char, readlen, blecb);\n    })\n  }\n\n\n  /**\n   * Request a notification from a GATT Characteristic on a device\n   * \n   * Requesting a disable will also cause the callback to be forgotten.\n   * \n   * @param mac MAC address of device\n   * @param char Characteristic to notify on\n   * @param enable Enable or disable the notify\n   * @param respcallback Callback to call when response to request for notify comes back\n   * @param upcallback Callback to call when notifies come in, in future.\n   * \n   * Throws an error if you attempt to enable a notify twice. Disable twice is ignored.\n   */\n  requestGATTSetNotify = (mac : string, char : string, enable : boolean, respcallback: I_BLEResponseCallback, upcallback : I_BLEUpdateCallback) => {\n    const key : T_NotifyKey = { MAC : mac, Char : char} as T_NotifyKey;\n    \n    const trampoline = BLE._makeResponseTrampoline(respcallback)\n\n    if (enable) {\n      // if (this.NotifyCallbackMap.has(key)) {\n      //   // Key already exists, so complain\n      //   throw new Error(`There is already a notify callback for ${key.MAC + key.Char}`);\n      // }\n      this.NotifyCallbackMap.set(key, upcallback);\n      this._sendRequest(this.MM.makeGATTSetNotify(mac, char, enable, 0), trampoline);\n    } else {\n      if (this.NotifyCallbackMap.has(key)) {\n        this._sendRequest(this.MM.makeGATTSetNotify(mac, char, enable, 0), trampoline);\n        this.NotifyCallbackMap.delete(key)      \n      }\n    }\n  }\n\n/**\n * Request a notification from a GATT Characteristic on a device.\n * \n * This is just like requestGATTSetNotify, but is async, and throws an\n * exception if the attempt to set the notify fails, instead of requiring you to\n * set a callback.\n * \n * Requesting a disable will cause the callback to be forgotten.\n * \n * @param mac MAC address of device\n * @param char Characteristic to notify on\n * @param enable Enable or disable the notify\n * @param upcallback Callback to call when notifies come in, in future.\n * \n * Throws an error if you attempt to enable a notify twice. Disable twice is ignored.\n */\n  requestAsyncGATTSetNotify = async (mac : string, char : string, enable : boolean, upcallback : I_BLEUpdateCallback) : Promise<FullOption<T_Response, T_ErrorDesc>> => {\n    return new Promise<FullOption<T_Response, T_ErrorDesc>>((resolve, reject) => {\n      const respcallback : I_BLEResponseCallback = (request : T_Request, msg : T_FullResponseOption) : boolean => {\n        resolve(msg)\n\n        return false;  \n      }\n\n      this.requestGATTSetNotify(mac, char, enable, respcallback, upcallback);\n    })\n  }\n\n  // This is a DE1 specific BLE request. Decided that I'd put it here, even though it's not\n  // a generic BLE operation.\n\n  /**\n   * This sets up internal state so that this BLE object can transparently handle\n   * MMR reads for you, to a DE1.\n   * \n   * @param mac MAC address of a DE1\n   * @returns  \n   */\n  setUpForMMRReads = async (mac: string) : Promise<SuccessOption<T_ErrorDesc>> => {\n    return new Promise<SuccessOption<T_ErrorDesc>>((resolve, reject) => {\n      const respcallback : I_BLEResponseCallback = (request : T_Request, response : T_FullResponseOption) : boolean => {\n        resolve(response);\n        return false;  \n      }\n\n      this.requestGATTSetNotify(mac, BLE.MMRReadChar, true, respcallback, this._wrapWithMAC(mac, this._localMMRUpdateCB));\n    })\n  }\n\n  // Convert a Base64 representation of an MMR to its constituent fields.\n  static _unpackMMRData(data : T_Base64String) {\n    const bindata = Buffer.from(data, \"base64\");\n    const wordlen = bindata[0];\n    const addr = (bindata[1] << 16) + (bindata[2] << 8) + (bindata[3]);\n    const payload = bindata.slice(4);\n    return { wordlen, addr, payload };\n  }\n\n  // Make a buffer that represents a MMR read\n  static _packMMRRead(wordlen : number, addr : number) : Buffer {\n    const data = new Uint8Array(20);\n    var header = [\n      wordlen,\n      (addr >> 16) & 0xFF,\n      (addr >>  8) & 0xFF,\n      addr        & 0xFF\n    ]\n    data.set(header, 0);\n    return Buffer.from(data);\n  }\n  \n  // Wrap a call so that the called function knows the MAC address of the counterparty BLE device.\n  _wrapWithMAC = (mac : string, callback : CallableFunction ) : I_BLEUpdateCallback => {\n    const cbfn : I_BLEUpdateCallback = ( msg : T_IncomingMsg ): boolean=> {\n      callback(mac, msg);\n      return false;\n    }\n    return cbfn;\n  }\n\n  // Called back when we get a notify update from the DE1. We don't know which DE1, so accept a MAC too.\n  _localMMRUpdateCB = (mac : string, msg : T_IncomingMsg) => {\n    if ((msg.type === \"UPDATE\") && (msg.update === \"GATTNotify\")) {\n      const gattn = msg as T_UpdateGATTNotify;\n      const res = BLE._unpackMMRData(gattn.results.Data);\n\n      const cb = this.MMRMap.get({ MAC : mac, Addr: res.addr });\n      if (cb !== undefined) {\n        cb(true, mac, res.wordlen, res.addr, res.payload);\n      };\n\n      console.log(`_locallMMRUpdateCB(${mac}, ${msg}):`, res);\n    }\n    \n    // If there's a chance we could now trigger a new read, do so.\n    if (this.PendingMMRReads.length > 0) {\n      setTimeout(this._procPendingMMRReads, 0);\n    }\n\n    return true;\n  }\n\n  static MMRReadChar = \"0000a005-0000-1000-8000-00805f9b34fb\";\n\n  // Look to see if we have any MMR reads we could do\n  // Returns true if it pulled a read out of the queue\n  _procPendingMMRRead = () : boolean => {\n    console.log(\"_procPendingMMRRead length: \", this.PendingMMRReads.length);\n    const oldestitem = this.PendingMMRReads.at(0);\n    if (oldestitem) {\n      const key = { MAC: oldestitem.mac, Addr: oldestitem.mmraddress };\n      if (!this.MMRMap.has(key)) {\n        // Okay. No existing read for this address. Let's do it.\n        // We can only have one read outstanding per address, as we only\n        // have the address to key on.\n        this.PendingMMRReads.shift(); // Discard from queue\n        const item = oldestitem;\n        const blecb = (request : T_Request, response : T_FullResponseOption): boolean => {\n          console.log(\"blecb: \", request, response)\n          // If the write succeeded \n          if (response.success) {\n              // Success, add notify to map, for response\n              // (this is now redundant, as we add it below)\n              // this.MMRMap.set({ MAC: item.mac, Addr: item.mmraddress }, item.callback);\n          } else {\n              // Something went wrong, so return error to callback, delete MMR callback entry\n              this.MMRMap.delete({ MAC: item.mac, Addr: item.mmraddress })\n              item.callback(false, item.mac, item.wordlen, item.mmraddress, null);\n          }\n\n          setTimeout(this._procPendingMMRReads, 1);\n          return false;\n        }\n\n        var data = BLE._packMMRRead(item.wordlen, item.mmraddress);\n        // Do the GATT write that will trigger a notify callback\n        // Apparently we can get the notify before the response comes back, so record the callback now.\n        this.MMRMap.set({ MAC: item.mac, Addr: item.mmraddress }, item.callback);\n        this.requestGATTWrite(item.mac, BLE.MMRReadChar, data, true, blecb);\n        return true; \n      }\n    }\n\n    return false;\n  }\n\n  // This method reads as many as possible pending MMR requests out of the queue and sends them.\n  _procPendingMMRReads = () => {\n    do {\n      console.log(\"PendingMMRReads:\", this.PendingMMRReads.length);\n      var didread = this._procPendingMMRRead()\n    } while (didread);\n  }\n\n  /**\n   * Request a read from an MMR\n   * @param mac MAC address of target device\n   * @param mmraddress Address to read from\n   * @param wordlen Number of words to read\n   * @param callback MMRCallback to call when we have data\n   */\n  requestMMRRead = (mac: string, mmraddress : number, wordlen : number, callback : MMRCallback) => {\n    console.log(\"requestMMRRead\");\n    const key : T_NotifyKey = { MAC : mac, Char : BLE.MMRReadChar} as T_NotifyKey;\n  \n    if (!this.NotifyCallbackMap.has(key)) {\n      throw new Error(\"Call setUpForMMRReads() once first, to enable MMR reads\");\n    }\n\n    const readreq : MMRReadReq = {\n      mac, mmraddress, wordlen, callback\n    }\n\n    // Put the MMR read request on the pending queue.\n    const len = this.PendingMMRReads.push(readreq);\n    console.log(\"PendingMMRReads len:\", len);\n\n    console.log(\"requestMMRRead pushed read: \", this.PendingMMRReads);\n    // Now pick reads off the queue\n    this._procPendingMMRReads();\n  }\n\n\n  /**\n   * Request a read from an MMR\n   * @param mac MAC address of target device\n   * @param mmraddress Address to read from\n   * @param wordlen Number of words to read\n   * @returns MMRReadResponse \n   */\n  requestAsyncMMRRead = async (mac: string, mmraddress : number, wordlen : number, ) => {\n    console.log(\"requestAsyncMMRRead\");\n    return new Promise<MMRReadResponse>( (resolve, reject) => {\n      const mmrcb : MMRCallback = (success, mac, wordlen, addr, payload) => {\n        if (success && (payload !== null)) {\n          resolve({mac, mmraddress, wordlen, payload});\n        } else {\n          reject(new Error(`MMR read to ${mac} ${mmraddress.toString(16)} failed for unknown reason.`))\n        }\n      }  \n\n      // Request the read, could throw an error.\n      this.requestMMRRead(mac, mmraddress, wordlen, mmrcb);\n    });\n  }\n\n\n  /**\n   * It's not entirely clear to me what we should do when the websocket connection is lost.\n   * \n   * Should I just reset everything?\n   * \n   * I starting to think that I shouldn't even keep a local list of seen and connected devices,\n   * as we run the risk of getting out of sync.\n   */\n  reset = () => {\n    this.SeenDevices.clear();\n    this.ConnectedDevices.clear();\n    this.NotifyCallbackMap.clear();\n    this.SentMap.clear();\n    this.PendingMMRReads = [];\n  }\n\n  constructor(name: string, url: string){\n    console.log(\"BLE.constructor(%s, %s)\", name, url);\n    this.PendingMMRReads = [];\n    this.LastID = 1;\n    this.MM = new MessageMaker();    \n    this.URL = url;\n    this.Name = name;\n    this.WSCName = \"wsc_\"+name;\n    this.WSC = new WSClientController(this.WSCName, url);\n    this.WSC.addStateNotify(this._onstatechange);\n    this.WSC.setMessageEventHandler(this._onmessage)\n    this.WSC.connect()\n   }\n\n}\n","import KeyStore from '../models/KeyStore';\n\nexport type WSClientNotifyFn = () => void;\n\ninterface I_WSMessageCallback {\n  (ev: MessageEvent<any>) : any\n}\n\nexport type WSState = WebSocket[\"CLOSED\"] | WebSocket[\"CLOSING\"] | WebSocket[\"CONNECTING\"] | WebSocket[\"OPEN\"];\n\nexport class WSClientController {\n\n  Name : string;  // Name this controller will use. Used as ownername in KeyStore keys.\n  URL  : string;  // Target address\n  ReconnectHandle : any;\n  RetryInterval   : number;\n  MaxRetry : number;\n  Notifies : Set<any>;\n  Model    : KeyStore;\n  OnMessageCallback : I_WSMessageCallback | null;\n\n  // I don't want to initialise ws until connect is called, and there's no way to stop\n  // TS from complaining that I've been able to find.\n  WS       : WebSocket | null;\n\n  constructor(name: string, url: string) {\n    if (!name) throw Error(\"Please specify a name for this controller\");\n    if (!url)  throw Error(\"Please specify a url for this controller\");\n\n    console.log(\"Creating new WSClientController:\", name, \"for\", url);\n    this.Name = name;\n    this.URL = url // \"ws://localhost:8765\"\n    this.ReconnectHandle = null;\n    this.RetryInterval = 250; // Current ms between retries. Increments by 250ms after each failed retry.\n    this.MaxRetry = 10000;    // Maximum delay between retries, in milliseconds\n    this.Notifies = new Set([])\n    this.Model = KeyStore.getInstance();\n    this.Model.updateKey(name, \"url\", this.URL);\n    this.Model.updateKey(name, \"readyState\", WebSocket.CLOSED as WSState);\n    this.OnMessageCallback = null\n    this.WS = null\n  }\n\n  _clearReconnectTimeout() {\n    if (this.ReconnectHandle) {\n      window.clearTimeout(this.ReconnectHandle); // We are connected, so get rid of our reconnect Timer\n      this.ReconnectHandle = null;\n    }\n    this.RetryInterval = 250; // Reset interval to 250ms\n  }\n\n  // Called by websocket when connected\n  _on_open = () => {\n    console.log(\"WebSocket connected\");\n\n    this._clearReconnectTimeout();\n    this.notifyStateListeners();\n    this.Model.updateKey(this.Name, \"readyState\", this.getReadyState(), true)\n  }\n\n\n    // Called by WebSocket when closed\n  _on_close = (e: CloseEvent) => {\n    console.log(\n      `Socket is closed. Reconnect will be attempted in ${this.RetryInterval} milliseconds.`,\n      e.reason\n    );\n\n    const interval = Math.min(this.MaxRetry, this.RetryInterval + 250)\n    this.ReconnectHandle = setTimeout(this.checkConnection, interval); // Call check function after timeout\n    this.RetryInterval = interval;\n    this.notifyStateListeners();\n    this.Model.updateKey(this.Name, \"readyState\", this.getReadyState())\n  };\n\n  // Called by ws when something goes wrong\n  _on_error = (errorevent : Event) => {\n    console.error(\n      \"Socket encountered error: \",\n      errorevent,\n      \"Closing socket\"\n    );\n\n    this.WS?.close();\n    this.notifyStateListeners();\n\n    this.Model.updateKey(this.Name, \"readyState\", this.getReadyState(), true)\n  }\n\n  _on_message = (event: MessageEvent<any>) => {\n    if (this.OnMessageCallback) {\n      return this.OnMessageCallback(event)\n    }\n  }\n\n  getReadyState() : WSState {\n    return this.WS?.readyState || WebSocket.CLOSED\n  }\n\n  connect() {\n    if (this.WS == null) {\n      this.WS = new WebSocket(this.URL);\n    }\n\n    if ( (this.WS.readyState === WebSocket.CLOSED) || (this.WS.readyState === WebSocket.CLOSING) ) {\n      this.WS = new WebSocket(this.URL);\n    }\n    this.WS.onopen = this._on_open\n    this.WS.onclose = this._on_close\n    this.WS.onerror = this._on_error\n    this.WS.onmessage = this._on_message\n    this.notifyStateListeners();\n  };\n\n  setMessageEventHandler(callback : (ev: MessageEvent<any>) => any) {\n    console.log(\"setMessageEventHandler: \", callback)\n    this.OnMessageCallback = callback;\n  }\n\n  send(data: string | ArrayBufferLike | Blob | ArrayBufferView) {\n    this.WS?.send(data)\n  }\n\n  /**\n   * Get state in a way that can be easily rendered by React\n   */\n  getState() {\n    return {\n      url: this.URL,\n      readyState: this.getReadyState()\n    }\n  }\n\n  addStateNotify(notifyfn: WSClientNotifyFn) {\n    this.Notifies.add(notifyfn)\n  }\n\n  removeNotify(notifyfn: WSClientNotifyFn) {\n    this.Notifies.delete(notifyfn)\n  }\n\n\n  /**\n   * checkConnection: Called when retry timer triggers\n   */\n  checkConnection = () => {\n    if (!this.WS || this.WS.readyState === WebSocket.CLOSED) this.connect(); // Reconnect if necessary\n  };\n\n  notifyStateListeners() {\n    this.Notifies.forEach(element => {\n      element();\n    });\n  }\n}\n\n// End of WSClientController\n"],"sourceRoot":""}